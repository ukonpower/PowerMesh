!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("three"),require("ore-three-ts")):"function"==typeof define&&define.amd?define(["three","ore-three-ts"],n):"object"==typeof exports?exports.PowerMesh=n(require("three"),require("ore-three-ts")):t.PowerMesh=n(t.THREE,t.ORE)}(self,(function(t,n){return(()=>{"use strict";var e={644:t=>{t.exports=n},381:n=>{n.exports=t}},o={};function a(t){var n=o[t];if(void 0!==n)return n.exports;var i=o[t]={exports:{}};return e[t](i,i.exports,a),i.exports}a.d=(t,n)=>{for(var e in n)a.o(n,e)&&!a.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:n[e]})},a.o=(t,n)=>Object.prototype.hasOwnProperty.call(t,n),a.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var i={};return(()=>{a.r(i),a.d(i,{PowerMesh:()=>r});var t=a(381),n=a(644);const e="#define GLSLIFY 1\nattribute vec4 tangent;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewNormal;\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\nvarying vec3 vViewPos;\nvarying vec3 vWorldPos;\nvarying vec2 vHighPrecisionZW;\n\n/*-------------------------------\n\tShadowMap\n-------------------------------*/\n\n#include <shadowmap_pars_vertex>\n\nvoid main( void ) {\n\n\t/*-------------------------------\n\t\tPosition\n\t-------------------------------*/\n\n\tvec3 pos = position;\n\tvec4 worldPos = modelMatrix * vec4( pos, 1.0 );\n\tvec4 mvPosition = viewMatrix * worldPos;\n\t\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t/*-------------------------------\n\t\tNormal / Tangent\n\t-------------------------------*/\n\n\tvec3 transformedNormal = normalMatrix * normal;\n\tvec4 flipedTangent = tangent;\n\tflipedTangent.w *= -1.0;\n\n\t#ifdef FLIP_SIDED\n\t\ttransformedNormal *= -1.0;\n\t\tflipedTangent *= -1.0;\n\t#endif\n\t\n\tvec3 normal = normalize( transformedNormal );\n\tvec3 tangent = normalize( ( modelViewMatrix * vec4( flipedTangent.xyz, 0.0 ) ).xyz );\n\tvec3 biTangent = normalize( cross( normal, tangent ) * flipedTangent.w );\n\n\t/*-------------------------------\n\t\tShadow\n\t-------------------------------*/\n\t\n\tvec4 shadowWorldPos;\n\t\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\t\n\t\t\tshadowWorldPos = worldPos + vec4( vec4( transformedNormal, 0.0 ) * modelMatrix ) * directionalLightShadows[ i ].shadowNormalBias;\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPos;\n\t\t\t\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t\n\t#endif\n\n\t/*-------------------------------\n\t\tVarying\n\t-------------------------------*/\n\t\n\tvUv = uv;\n\tvNormal = normal;\n\tvTangent = tangent;\n\tvBitangent = biTangent;\n\tvViewPos = -mvPosition.xyz;\n\tvWorldPos = worldPos.xyz;\n\tvHighPrecisionZW = gl_Position.zw;\n\t\n}",o="#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n\n/*-------------------------------\n\tRequire\n-------------------------------*/\n\n#define PI 3.14159265359\n#define TPI 6.28318530718\n#define HPI 1.57079632679\n\n#include <packing>\n\nvec2 packing16( float value ) { \n\n\tfloat v1 = value * 255.0;\n\tfloat r = floor(v1);\n\n\tfloat v2 = ( v1 - r ) * 255.0;\n\tfloat g = floor( v2 );\n\n\treturn vec2( r, g ) / 255.0;\n\n}\n\n/*-------------------------------\n\tRequiers\n-------------------------------*/\n\nfloat random(vec2 p){\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/*-------------------------------\n\tMaterial Uniforms\n-------------------------------*/\n\nuniform float time;\n\n/*-------------------------------\n\tTextures\n-------------------------------*/\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#else\n\n\tuniform vec3 color;\n\n#endif\n\n#ifdef USE_NORMAL_MAP\n\n\tuniform sampler2D normalMap;\n\n#endif\n\n#ifdef USE_ROUGHNESS_MAP\n\n\tuniform sampler2D roughnessMap;\n\n#else\n\n\tuniform float roughness;\n\n#endif\n\n#ifdef USE_ALPHA_MAP\n\n\tuniform sampler2D alphaMap;\n\n#else\n\n\tuniform float opacity;\n\t\n#endif\n\n#ifdef USE_METALNESS_MAP\n\n\tuniform sampler2D metalnessMap;\n\n#else\n\n\tuniform float metalness;\n\n#endif\n#ifdef USE_EMISSION_MAP\n\n\tuniform sampler2D emissionMap;\n\n#else\n\n\tuniform vec3 emission;\n\n#endif\n\n#ifdef REFLECTPLANE\n\n\tuniform sampler2D reflectionTex;\n\tuniform vec2 renderResolution;\n\tuniform vec2 mipMapResolution;\n\t\n#endif\n\n/*-------------------------------\n\tTypes\n-------------------------------*/\n\nstruct Geometry {\n\tvec3 pos;\n\tvec3 posWorld;\n\tvec3 viewDir;\n\tvec3 viewDirWorld;\n\tvec3 normal;\n\tvec3 normalWorld;\n};\n\nstruct Light {\n\tvec3 direction;\n\tvec3 color;\n};\n\nstruct Material {\n\tvec3 albedo;\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat metalness;\n\tfloat roughness;\n\tfloat opacity;\n};\n\n/*-------------------------------\n\tLights\n-------------------------------*/\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n#endif\n\n/*-------------------------------\n\tEnvMap\n-------------------------------*/\n\nuniform sampler2D envMap;\nuniform float envMapIntensity;\nuniform float iblIntensity;\nuniform float maxLodLevel;\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\n/*-------------------------------\n\tReflection\n-------------------------------*/\n\n#define REF_MIPMAP_LEVEL 8.0\n\n#ifdef REFLECTPLANE\n\n\tuniform vec3 a;\n\n\tvec2 getRefMipmapUV( vec2 uv, float level ) {\n\n\t\tvec2 ruv = uv;\n\n\t\tif( level > 0.0 ) {\n\n\t\t\truv.x *= 1.0 / ( 3.0 * ( pow( 2.0, level ) / 2.0 ) );\n\t\t\truv.y *= 1.0 / ( pow( 2.0, level ) );\n\t\t\truv.y += 1.0 / ( pow( 2.0, level ) );\n\t\t\truv.x += 1.0 / 1.5;\n\t\t\n\t\t} else {\n\n\t\t\truv.x /= 1.5;\n\t\t\t\n\t\t}\n\n\t\treturn ruv;\n\n\t}\n\t\n\tvec4 cubic(float v) {\n\t\tvec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n\t\tvec4 s = n * n * n;\n\t\tfloat x = s.x;\n\t\tfloat y = s.y - 4.0 * s.x;\n\t\tfloat z = s.z - 4.0 * s.y + 6.0 * s.x;\n\t\tfloat w = 6.0 - x - y - z;\n\t\treturn vec4(x, y, z, w);\n\t}\n\n\t// https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\tvec4 textureBicubic(sampler2D t, vec2 texCoords, vec2 textureSize) {\n\t\tvec2 invTexSize = 1.0 / textureSize;\n\t\ttexCoords = texCoords * textureSize - 0.5;\n\t\tvec2 fxy = fract(texCoords);\n\t\ttexCoords -= fxy;\n\t\tvec4 xcubic = cubic(fxy.x);\n\t\tvec4 ycubic = cubic(fxy.y);\n\t\tvec4 c = texCoords.xxyy + vec2 (-0.5, 1.5).xyxy;\n\t\tvec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n\t\tvec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n\t\toffset *= invTexSize.xxyy;\n\t\tvec4 sample0 = texture2D(t, offset.xz);\n\t\tvec4 sample1 = texture2D(t, offset.yz);\n\t\tvec4 sample2 = texture2D(t, offset.xw);\n\t\tvec4 sample3 = texture2D(t, offset.yw);\n\t\tfloat sx = s.x / (s.x + s.y);\n\t\tfloat sy = s.z / (s.z + s.w);\n\t\treturn mix(\n\t\tmix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n\t}\n\n#endif\n\n/*-------------------------------\n\tShadow\n-------------------------------*/\n\n#ifdef DEPTH\n\n\tvarying vec2 vHighPrecisionZW;\n\tuniform float cameraNear;\n\tuniform float cameraFar;\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#define SHADOW_SAMPLE_COUNT 4\n\n\tvec2 poissonDisk[ SHADOW_SAMPLE_COUNT ];\n\n\tvoid initPoissonDisk( float seed ) {\n\n\t\tfloat r = 0.1;\n\t\tfloat rStep = (1.0 - r) / float( SHADOW_SAMPLE_COUNT );\n\n\t\tfloat ang = random( gl_FragCoord.xy * 0.01 + sin( time ) ) * TPI * 1.0;\n\t\tfloat angStep = ( ( TPI * 11.0 ) / float( SHADOW_SAMPLE_COUNT ) );\n\t\t\n\t\tfor( int i = 0; i < SHADOW_SAMPLE_COUNT; i++ ) {\n\n\t\t\tpoissonDisk[ i ] = vec2(\n\t\t\t\tsin( ang ),\n\t\t\t\tcos( ang )\n\t\t\t) * pow( r, 0.75 );\n\n\t\t\tr += rStep;\n\t\t\tang += angStep;\n\t\t}\n\t\t\n\t}\n\n\tvec2 compairShadowMapDepth( sampler2D shadowMap, vec2 shadowMapUV, float depth ) {\n\n\t\tif( shadowMapUV.x < 0.0 || shadowMapUV.x > 1.0 || shadowMapUV.y < 0.0 || shadowMapUV.y > 1.0 ) {\n\n\t\t\treturn vec2( 1.0, 0.0 );\n\n\t\t}\n\n\t\tfloat shadowMapDepth = unpackRGBAToDepth( texture2D( shadowMap, shadowMapUV ) );\n\n\t\tif( 0.0 >= shadowMapDepth || shadowMapDepth >= 1.0 ) {\n\n\t\t\treturn vec2( 1.0, 0.0 );\n\n\t\t}\n\t\t\n\t\tfloat shadow = depth <= shadowMapDepth ? 1.0 : 0.0;\n\n\t\treturn vec2( shadow, shadowMapDepth );\n\t\t\n\t}\n\n\tfloat shadowMapPCF( sampler2D shadowMap, vec4 shadowMapCoord, vec2 shadowSize ) {\n\n\t\tfloat shadow = 0.0;\n\t\t\n\t\tfor( int i = 0; i < SHADOW_SAMPLE_COUNT; i ++  ) {\n\t\t\t\n\t\t\tvec2 offset = poissonDisk[ i ] * shadowSize; \n\n\t\t\tshadow += compairShadowMapDepth( shadowMap, shadowMapCoord.xy + offset, shadowMapCoord.z ).x;\n\t\t\t\n\t\t}\n\n\t\tshadow /= float( SHADOW_SAMPLE_COUNT );\n\n\t\treturn shadow;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float bias, vec4 shadowMapCoord ) {\n\t\t\n\t\tshadowMapCoord.xyz /= shadowMapCoord.w;\n\t\tshadowMapCoord.z += bias - 0.0001;\n\n\t\tinitPoissonDisk(time);\n\n\t\tvec2 shadowSize = 1.0 / shadowMapSize;\n\n\t\treturn shadowMapPCF( shadowMap, shadowMapCoord, shadowSize );\n\n\t}\n\n#endif\n\n/*-------------------------------\n\tRE\n-------------------------------*/\n\nvarying vec3 vNormal;\nvarying vec3 vViewNormal;\nvarying vec3 vViewPos;\nvarying vec3 vWorldPos;\n\nfloat ggx( float dNH, float roughness ) {\n\t\n\tfloat a2 = roughness * roughness;\n\ta2 = a2 * a2;\n\tfloat dNH2 = dNH * dNH;\n\n\tif( dNH2 <= 0.0 ) return 0.0;\n\n\treturn a2 / ( PI * pow( dNH2 * ( a2 - 1.0 ) + 1.0, 2.0) );\n\n}\n\nvec3 lambert( vec3 diffuseColor ) {\n\n\treturn diffuseColor / PI;\n\n}\n\nfloat gSchlick( float d, float k ) {\n\n\tif( d == 0.0 ) return 0.0;\n\n\treturn d / ( d * ( 1.0 - k ) + k );\n\t\n}\n\nfloat gSmith( float dNV, float dNL, float roughness ) {\n\n\tfloat k = clamp( roughness * sqrt( 2.0 / PI ), 0.0, 1.0 );\n\n\treturn gSchlick( dNV, k ) * gSchlick( dNL, k );\n\t\n}\n\nfloat fresnel( float d ) {\n\t\n\tfloat f0 = 0.04;\n\n\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - d, 5.0 );\n\n}\n\nvec3 RE( Geometry geo, Material mat, Light light) {\n\n\tvec3 lightDir = normalize( light.direction );\n\tvec3 halfVec = normalize( geo.viewDir + lightDir );\n\n\tfloat dLH = clamp( dot( lightDir, halfVec ), 0.0, 1.0 );\n\tfloat dNH = clamp( dot( geo.normal, halfVec ), 0.0, 1.0 );\n\tfloat dNV = clamp( dot( geo.normal, geo.viewDir ), 0.0, 1.0 );\n\tfloat dNL = clamp( dot( geo.normal, lightDir), 0.0, 1.0 );\n\n\tvec3 irradiance = light.color * dNL;\n\n\t// diffuse\n\tvec3 diffuse = lambert( mat.diffuseColor ) * irradiance;\n\n\t// specular\n\tfloat D = ggx( dNH, mat.roughness );\n\tfloat G = gSmith( dNV, dNL, mat.roughness );\n\tfloat F = fresnel( dLH );\n\t\n\tvec3 specular = (( D * G * F ) / ( 4.0 * dNL * dNV + 0.0001 ) * mat.specularColor ) * irradiance; \n\n\tvec3 c = vec3( 0.0 );\n\tc += diffuse * ( 1.0 - F ) + specular;\n\n\treturn c;\n\n}\n\n/*-------------------------------\n\tMain\n-------------------------------*/\n\nvoid main( void ) {\n\n\t/*-------------------------------\n\t\tMaterial\n\t-------------------------------*/\n\n\tMaterial mat;\n\n\t#ifdef USE_MAP\n\n\t\tvec4 color = LinearTosRGB( texture2D( map, vUv ) );\n\t\tmat.albedo = color.xyz;\n\n\t#else\n\n\t\tmat.albedo = color.xyz;\n\t\tmat.opacity = 1.0;\n\t\n\t#endif\n\n\t#ifdef USE_ROUGHNESS_MAP\n\n\t\tmat.roughness = texture2D( roughnessMap, vUv ).y;\n\n\t#else\n\n\t\tmat.roughness = roughness;\n\t\n\t#endif\n\n\t#ifdef USE_METALNESS_MAP\n\n\t\tmat.metalness = texture2D( metalnessMap, vUv ).z;\n\n\t#else\n\n\t\tmat.metalness = metalness;\n\t\n\t#endif\n\n\t#ifdef USE_ALPHA_MAP\n\n\t\tmat.opacity = texture2D( alphaMap, vUv ).x;\n\n\t#else\n\n\t\tmat.opacity = opacity;\n\n\t#endif\n\t\n\tif( mat.opacity < 0.5 ) discard;\n\n\tmat.diffuseColor = mix( mat.albedo, vec3( 0.0, 0.0, 0.0 ), mat.metalness );\n\tmat.specularColor = mix( vec3( 1.0, 1.0, 1.0 ), mat.albedo, mat.metalness );\n\n\t// output\n\tvec3 outColor = vec3( 0.0 );\n\tfloat outOpacity = mat.opacity;\n\n\t/*-------------------------------\n\t\tDepth\n\t-------------------------------*/\n\n\t#ifdef DEPTH\n\n\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW.x / vHighPrecisionZW.y + 0.5;\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t\treturn;\n\t\n\t#endif\n\n\t/*-------------------------------\n\t\tGeometry\n\t-------------------------------*/\n\n\tfloat faceDirection = gl_FrontFacing ? 1.0 : -1.0;\n\n\tGeometry geo;\n\tgeo.pos = -vViewPos;\n\tgeo.posWorld = vWorldPos;\n\tgeo.viewDir = normalize( vViewPos );\n\tgeo.viewDirWorld = normalize( geo.posWorld - cameraPosition );\n\tgeo.normal = normalize( vNormal ) * faceDirection;\n\n\t#ifdef USE_NORMAL_MAP\n\t\t\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent *= faceDirection;\n\t\t\tbitangent *= faceDirection;\n\t\t\n\t\t#endif\n\t\t\n\t\tmat3 vTBN = mat3( tangent, bitangent, geo.normal );\n\t\t\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz;\n\t\tmapN = mapN * 2.0 - 1.0;\n\t\tgeo.normal = normalize( vTBN * mapN );\n\n\t#endif\n\t\n\tgeo.normalWorld = normalize( ( vec4( geo.normal, 0.0 ) * viewMatrix ).xyz );\n\n\t/*-------------------------------\n\t\tLighting\n\t-------------------------------*/\n\t\n\tLight light;\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\tlight.direction = directionalLights[ i ].direction;\n\t\t\t\tlight.color = directionalLights[ i ].color;\n\n\t\t\t\tfloat shadow = 1.0;\n\t\t\t\t\n\t\t\t\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\t\t\t\tshadow = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ].shadowMapSize, directionalLightShadows[ i ].shadowBias, vDirectionalShadowCoord[ i ] );\n\n\t\t\t\t#endif\n\n\t\t\t\toutColor += RE( geo, mat, light ) * shadow;\n\t\t\t\t\n\t\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tPointLight pLight;\n\t\tvec3 v;\n\t\tfloat d;\n\t\tfloat attenuation;\n\t\t#pragma unroll_loop_start\n\n\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\t\tpLight = pointLights[ i ];\n\n\t\t\t\tv = pLight.position - geo.pos;\n\t\t\t\td = length( v );\n\t\t\t\tlight.direction = normalize( v );\n\t\t\n\t\t\t\tlight.color = pLight.color;\n\n\t\t\t\tif( pLight.distance > 0.0 && pLight.decay > 0.0 ) {\n\n\t\t\t\t\tattenuation = pow( clamp( -d / pLight.distance + 1.0, 0.0, 1.0 ), pLight.decay );\n\t\t\t\t\tlight.color *= attenuation;\n\n\t\t\t\t}\n\n\t\t\t\toutColor += RE( geo, mat, light );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*-------------------------------\n\t\tEnvironment Lighting\n\t-------------------------------*/\n\n\tfloat dNV = clamp( dot( geo.normal, geo.viewDir ), 0.0, 1.0 );\n\n\tvec3 refDir = reflect( geo.viewDirWorld, geo.normalWorld );\n\trefDir.x *= -1.0;\n\n\tvec4 envMapColor = LinearTosRGB( textureCubeUV( envMap, geo.normalWorld, 1.0 ) ) * iblIntensity * envMapIntensity;\n\toutColor += mat.diffuseColor * envMapColor.xyz * ( 1.0 - mat.metalness );\n\n\t/*-------------------------------\n\t\tReflection\n\t-------------------------------*/\n\t\n\tfloat EF = mix( fresnel( dNV ), 1.0, mat.metalness );\n\n\t#ifdef REFLECTPLANE\n\t\n\t\tvec2 refUV = gl_FragCoord.xy / renderResolution;\n\n\t\trefUV.x += geo.normal.x * 0.5;\n\n\t\tfloat l = (1.0 - exp( -mat.roughness  ) ) * 1.6 * REF_MIPMAP_LEVEL;\n\n\t\tfloat offset1 = floor( l );\n\t\tfloat offset2 = offset1 + 1.0;\n\t\tfloat blend = fract( l );\n\t\t\n\t\tvec2 ruv1 = getRefMipmapUV( refUV, offset1 );\n\t\tvec2 ruv2 = getRefMipmapUV( refUV, offset2 );\n\n\t\tvec3 ref1 = textureBicubic( reflectionTex, ruv1, mipMapResolution ).xyz;\n\t\tvec3 ref2 = textureBicubic( reflectionTex, ruv2, mipMapResolution ).xyz;\n\n\t\toutColor += mix( ref1, ref2, blend ) * EF;\n\n\t#else\n\t\n\t\toutColor += mat.specularColor * LinearTosRGB( textureCubeUV( envMap, refDir, mat.roughness ) ).xyz * EF * envMapIntensity;\n\t\n\t#endif\n\n\t/*-------------------------------\n\t\tEmission\n\t-------------------------------*/\n\n\t#ifdef USE_EMISSION_MAP\n\n\t\toutColor += LinearTosRGB( texture2D( emissionMap, vUv ) ).xyz;\n\t\n\t#else\n\n\t\toutColor += emission;\n\n\t#endif\n\n\tgl_FragColor = vec4( outColor, outOpacity );\n\n}";class r extends t.Mesh{constructor(a,i){i=i||{};let r,s=n.UniformsLib.mergeUniforms(i.uniforms||{},{envMap:{value:null},envMapIntensity:{value:null},iblIntensity:{value:null},maxLodLevel:{value:0},shadowLightModelViewMatrix:{value:new t.Matrix4},shadowLightProjectionMatrix:{value:new t.Matrix4},shadowLightDirection:{value:new t.Vector3},shadowLightCameraClip:{value:new t.Vector2},shadowMap:{value:null},shadowMapSize:{value:new t.Vector2},shadowMapResolution:{value:new t.Vector2},shadowLightSize:{value:1},cameraNear:{value:.01},cameraFar:{value:1e3}});if(s=n.UniformsLib.mergeUniforms(s,t.UniformsUtils.clone(t.UniformsLib.lights)),"isBufferGeometry"in a)r=a;else if("isMesh"in a){r=a.geometry;let t=a.material;t.isMeshStandardMaterial&&(t.map?s.map={value:t.map}:t.color&&(s.color={value:t.color}),t.roughnessMap?s.roughnessMap={value:t.roughnessMap}:s.roughness={value:t.roughness},t.alphaMap?s.alphaMap={value:t.alphaMap}:s.opacity={value:t.opacity},t.metalnessMap?s.metalnessMap={value:t.metalnessMap}:s.metalness={value:t.metalness},t.normalMap&&(s.normalMap={value:t.normalMap}),t.emissiveMap?s.emissionMap={value:t.emissiveMap}:s.emission={value:t.emissive})}else r=new t.BufferGeometry;r.getAttribute("tangent")||r.getIndex()&&r.getAttribute("position")&&r.getAttribute("normal")&&r.getAttribute("uv")&&r.computeTangents(),i.uniforms=s;let l=new t.ShaderMaterial(Object.assign({vertexShader:e,fragmentShader:o,lights:!0,transparent:!0,side:t.DoubleSide,extensions:{derivatives:!0},defines:{}},i));s.map&&(l.defines.USE_MAP=""),s.roughnessMap&&(l.defines.USE_ROUGHNESS_MAP=""),s.metalnessMap&&(l.defines.USE_METALNESS_MAP=""),s.alphaMap&&(l.defines.USE_ALPHA_MAP=""),s.normalMap&&(l.defines.USE_NORMAL_MAP=""),s.emissionMap&&(l.defines.USE_EMISSION_MAP=""),super(r,l),this.name=a.name,this.userData.colorMat=this.material,this.customDepthMaterial=new t.ShaderMaterial(Object.assign(Object.assign({vertexShader:e,fragmentShader:o,side:t.DoubleSide,lights:!0,extensions:{derivatives:!0}},i),{defines:Object.assign(Object.assign({},l.defines),{DEPTH:""})})),this.commonUniforms=s,"isMesh"in a&&(this.position.copy(a.position),this.rotation.copy(a.rotation),this.scale.copy(a.scale)),this.envMapSrc=null,this.envMapUpdate=!1,this.envMapRenderTarget=new t.WebGLCubeRenderTarget(256,{format:t.RGBAFormat,generateMipmaps:!0,magFilter:t.LinearFilter,minFilter:t.LinearFilter}),this.envMapCamera=new t.CubeCamera(.001,1e3,this.envMapRenderTarget),this.getWorldPosition(this.envMapCamera.position),this.onBeforeRender=(t,n,e)=>{this.dispatchEvent({type:"beforeRender",renderer:t,scene:n,camera:e})},this.addEventListener("beforeRender",(n=>{let e=n.renderer,o=n.scene,a=n.camera;if(this.envMapUpdate){let n=null,a=new t.PMREMGenerator(e);a.compileEquirectangularShader(),this.envMapSrc?n="isCubeTexture"in this.envMapSrc?a.fromCubemap(this.envMapSrc):a.fromEquirectangular(this.envMapSrc):(this.visible=!1,this.envMapCamera.update(e,o),n=a.fromCubemap(this.envMapRenderTarget.texture),this.visible=!0),this.commonUniforms.envMap.value=n.texture,this.envMapUpdate=!1}a.userData.depthCamera&&(this.material=this.userData.depthMat,this.commonUniforms.cameraNear.value=a.near,this.commonUniforms.cameraFar.value=a.far,this.material||(this.visible=!1))}));const d=()=>{this.envMapRenderTarget.dispose(),this.geometry.dispose(),this.material.dispose(),this.removeEventListener("dispose",d)};this.addEventListener("dispose",d)}updateEnvMap(t=null){this.envMapSrc=t,this.envMapUpdate=!0,null==this.commonUniforms.envMapIntensity.value&&(this.commonUniforms.envMapIntensity.value=1),null==this.commonUniforms.iblIntensity.value&&(this.commonUniforms.iblIntensity.value=1)}set envMapIntensity(t){this.commonUniforms.envMapIntensity.value=t}set iblIntensity(t){this.commonUniforms.iblIntensity.value=t}dispose(){this.dispatchEvent({type:"dispsoe"})}get isPowerMesh(){return!0}}})(),i})()}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixPQUFRYixFQUFVQyxHQUNwQ00sRUFBV0MsRUFBZUUsWUFBYTlCLEtBQUtZLG1CQUFtQnNCLFNBRS9EbEMsS0FBS2dDLFNBQVUsR0FJaEJoQyxLQUFLSyxlQUFldkQsT0FBT1IsTUFBUXFGLEVBQVNPLFFBQzVDbEMsS0FBS1csY0FBZSxFQVFoQlcsRUFBT3BCLFNBQVNpQyxjQUVwQm5DLEtBQUtsQyxTQUFXa0MsS0FBS0UsU0FBU2tDLFNBQzlCcEMsS0FBS0ssZUFBZTNDLFdBQVdwQixNQUFRZ0YsRUFBT2UsS0FDOUNyQyxLQUFLSyxlQUFlMUMsVUFBVXJCLE1BQVFnRixFQUFPZ0IsSUFFdEN0QyxLQUFLbEMsV0FFWGtDLEtBQUtnQyxTQUFVLE9BOEJsQixNQUFNTyxFQUFZLEtBRWpCdkMsS0FBS1ksbUJBQW1CNEIsVUFDeEJ4QyxLQUFLcEMsU0FBUzRFLFVBQ2R4QyxLQUFLbEMsU0FBUzBFLFVBRWR4QyxLQUFLeUMsb0JBQXFCLFVBQVdGLElBSXRDdkMsS0FBS3lCLGlCQUFrQixVQUFXYyxHQVE1QkcsYUFBYzVGLEVBQW1ELE1BRXZFa0QsS0FBS1UsVUFBWTVELEVBQ2pCa0QsS0FBS1csY0FBZSxFQUU4QixNQUE3Q1gsS0FBS0ssZUFBZXRELGdCQUFnQlQsUUFFeEMwRCxLQUFLSyxlQUFldEQsZ0JBQWdCVCxNQUFRLEdBSUUsTUFBMUMwRCxLQUFLSyxlQUFlckQsYUFBYVYsUUFFckMwRCxLQUFLSyxlQUFlckQsYUFBYVYsTUFBUSxHQU1oQ1Msb0JBQWlCVCxHQUUzQjBELEtBQUtLLGVBQWV0RCxnQkFBZ0JULE1BQVFBLEVBSWxDVSxpQkFBY1YsR0FFeEIwRCxLQUFLSyxlQUFlckQsYUFBYVYsTUFBUUEsRUFJbkNrRyxVQUVOeEMsS0FBS3VCLGNBQWUsQ0FBRUMsS0FBTSxZQUlsQm1CLGtCQUVWLE9BQU8sSyIsInNvdXJjZXMiOlsid2VicGFjazovL1Bvd2VyTWVzaC93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vUG93ZXJNZXNoL2V4dGVybmFsIHVtZCB7XCJjb21tb25qc1wiOlwib3JlLXRocmVlLXRzXCIsXCJjb21tb25qczJcIjpcIm9yZS10aHJlZS10c1wiLFwiYW1kXCI6XCJvcmUtdGhyZWUtdHNcIixcInJvb3RcIjpcIk9SRVwifSIsIndlYnBhY2s6Ly9Qb3dlck1lc2gvZXh0ZXJuYWwgdW1kIHtcImNvbW1vbmpzXCI6XCJ0aHJlZVwiLFwiY29tbW9uanMyXCI6XCJ0aHJlZVwiLFwiYW1kXCI6XCJ0aHJlZVwiLFwicm9vdFwiOlwiVEhSRUVcIn0iLCJ3ZWJwYWNrOi8vUG93ZXJNZXNoL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL1Bvd2VyTWVzaC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vUG93ZXJNZXNoL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vUG93ZXJNZXNoL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vUG93ZXJNZXNoLy4vc3JjL1Bvd2VyTWVzaC9zaGFkZXJzL3Bvd2VyLnZzIiwid2VicGFjazovL1Bvd2VyTWVzaC8uL3NyYy9Qb3dlck1lc2gvc2hhZGVycy9wb3dlci5mcyIsIndlYnBhY2s6Ly9Qb3dlck1lc2gvLi9zcmMvUG93ZXJNZXNoL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInRocmVlXCIpLCByZXF1aXJlKFwib3JlLXRocmVlLXRzXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInRocmVlXCIsIFwib3JlLXRocmVlLXRzXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlBvd2VyTWVzaFwiXSA9IGZhY3RvcnkocmVxdWlyZShcInRocmVlXCIpLCByZXF1aXJlKFwib3JlLXRocmVlLXRzXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJQb3dlck1lc2hcIl0gPSBmYWN0b3J5KHJvb3RbXCJUSFJFRVwiXSwgcm9vdFtcIk9SRVwiXSk7XG59KShzZWxmLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zODFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNjQ0X18pIHtcbnJldHVybiAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzY0NF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzgxX187IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgR0xTTElGWSAxXFxuYXR0cmlidXRlIHZlYzQgdGFuZ2VudDtcXG5cXG52YXJ5aW5nIHZlYzIgdlV2O1xcbnZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbnZhcnlpbmcgdmVjMyB2Vmlld05vcm1hbDtcXG52YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxudmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zO1xcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3M7XFxudmFyeWluZyB2ZWMyIHZIaWdoUHJlY2lzaW9uWlc7XFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0U2hhZG93TWFwXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG5cXG52b2lkIG1haW4oIHZvaWQgKSB7XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0UG9zaXRpb25cXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHR2ZWMzIHBvcyA9IHBvc2l0aW9uO1xcblxcdHZlYzQgd29ybGRQb3MgPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvcywgMS4wICk7XFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gdmlld01hdHJpeCAqIHdvcmxkUG9zO1xcblxcdFxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0Tm9ybWFsIC8gVGFuZ2VudFxcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdHZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiBub3JtYWw7XFxuXFx0dmVjNCBmbGlwZWRUYW5nZW50ID0gdGFuZ2VudDtcXG5cXHRmbGlwZWRUYW5nZW50LncgKj0gLTEuMDtcXG5cXG5cXHQjaWZkZWYgRkxJUF9TSURFRFxcblxcdFxcdHRyYW5zZm9ybWVkTm9ybWFsICo9IC0xLjA7XFxuXFx0XFx0ZmxpcGVkVGFuZ2VudCAqPSAtMS4wO1xcblxcdCNlbmRpZlxcblxcdFxcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcdHZlYzMgdGFuZ2VudCA9IG5vcm1hbGl6ZSggKCBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBmbGlwZWRUYW5nZW50Lnh5eiwgMC4wICkgKS54eXogKTtcXG5cXHR2ZWMzIGJpVGFuZ2VudCA9IG5vcm1hbGl6ZSggY3Jvc3MoIG5vcm1hbCwgdGFuZ2VudCApICogZmxpcGVkVGFuZ2VudC53ICk7XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0U2hhZG93XFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFx0XFxuXFx0dmVjNCBzaGFkb3dXb3JsZFBvcztcXG5cXHRcXG5cXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXHRcXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVF9TSEFET1dTOyBpICsrICkge1xcblxcdFxcdFxcdFxcblxcdFxcdFxcdHNoYWRvd1dvcmxkUG9zID0gd29ybGRQb3MgKyB2ZWM0KCB2ZWM0KCB0cmFuc2Zvcm1lZE5vcm1hbCwgMC4wICkgKiBtb2RlbE1hdHJpeCApICogZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dOb3JtYWxCaWFzO1xcblxcdFxcdFxcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogc2hhZG93V29ybGRQb3M7XFxuXFx0XFx0XFx0XFxuXFx0XFx0fVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFx0XFx0XFxuXFx0I2VuZGlmXFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0VmFyeWluZ1xcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcdFxcblxcdHZVdiA9IHV2O1xcblxcdHZOb3JtYWwgPSBub3JtYWw7XFxuXFx0dlRhbmdlbnQgPSB0YW5nZW50O1xcblxcdHZCaXRhbmdlbnQgPSBiaVRhbmdlbnQ7XFxuXFx0dlZpZXdQb3MgPSAtbXZQb3NpdGlvbi54eXo7XFxuXFx0dldvcmxkUG9zID0gd29ybGRQb3MueHl6O1xcblxcdHZIaWdoUHJlY2lzaW9uWlcgPSBnbF9Qb3NpdGlvbi56dztcXG5cXHRcXG59XCI7IiwiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIEdMU0xJRlkgMVxcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyB2ZWMzIHZUYW5nZW50O1xcbnZhcnlpbmcgdmVjMyB2Qml0YW5nZW50O1xcblxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdFJlcXVpcmVcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4jZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcXG4jZGVmaW5lIFRQSSA2LjI4MzE4NTMwNzE4XFxuI2RlZmluZSBIUEkgMS41NzA3OTYzMjY3OVxcblxcbiNpbmNsdWRlIDxwYWNraW5nPlxcblxcbnZlYzIgcGFja2luZzE2KCBmbG9hdCB2YWx1ZSApIHsgXFxuXFxuXFx0ZmxvYXQgdjEgPSB2YWx1ZSAqIDI1NS4wO1xcblxcdGZsb2F0IHIgPSBmbG9vcih2MSk7XFxuXFxuXFx0ZmxvYXQgdjIgPSAoIHYxIC0gciApICogMjU1LjA7XFxuXFx0ZmxvYXQgZyA9IGZsb29yKCB2MiApO1xcblxcblxcdHJldHVybiB2ZWMyKCByLCBnICkgLyAyNTUuMDtcXG5cXG59XFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0UmVxdWllcnNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5mbG9hdCByYW5kb20odmVjMiBwKXtcXG5cXHRyZXR1cm4gZnJhY3Qoc2luKGRvdChwLnh5ICx2ZWMyKDEyLjk4OTgsNzguMjMzKSkpICogNDM3NTguNTQ1Myk7XFxufVxcblxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdE1hdGVyaWFsIFVuaWZvcm1zXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxudW5pZm9ybSBmbG9hdCB0aW1lO1xcblxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdFRleHR1cmVzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuI2lmZGVmIFVTRV9NQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuXFxuI2Vsc2VcXG5cXG5cXHR1bmlmb3JtIHZlYzMgY29sb3I7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9OT1JNQUxfTUFQXFxuXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfUk9VR0hORVNTX01BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDtcXG5cXG4jZWxzZVxcblxcblxcdHVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfQUxQSEFfTUFQXFxuXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxuXFxuI2Vsc2VcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxuXFx0XFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9NRVRBTE5FU1NfTUFQXFxuXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxuZXNzTWFwO1xcblxcbiNlbHNlXFxuXFxuXFx0dW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7XFxuXFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9FTUlTU0lPTl9NQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2lvbk1hcDtcXG5cXG4jZWxzZVxcblxcblxcdHVuaWZvcm0gdmVjMyBlbWlzc2lvbjtcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgUkVGTEVDVFBMQU5FXFxuXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgcmVmbGVjdGlvblRleDtcXG5cXHR1bmlmb3JtIHZlYzIgcmVuZGVyUmVzb2x1dGlvbjtcXG5cXHR1bmlmb3JtIHZlYzIgbWlwTWFwUmVzb2x1dGlvbjtcXG5cXHRcXG4jZW5kaWZcXG5cXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRUeXBlc1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbnN0cnVjdCBHZW9tZXRyeSB7XFxuXFx0dmVjMyBwb3M7XFxuXFx0dmVjMyBwb3NXb3JsZDtcXG5cXHR2ZWMzIHZpZXdEaXI7XFxuXFx0dmVjMyB2aWV3RGlyV29ybGQ7XFxuXFx0dmVjMyBub3JtYWw7XFxuXFx0dmVjMyBub3JtYWxXb3JsZDtcXG59O1xcblxcbnN0cnVjdCBMaWdodCB7XFxuXFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0dmVjMyBjb2xvcjtcXG59O1xcblxcbnN0cnVjdCBNYXRlcmlhbCB7XFxuXFx0dmVjMyBhbGJlZG87XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3I7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0IG1ldGFsbmVzcztcXG5cXHRmbG9hdCByb3VnaG5lc3M7XFxuXFx0ZmxvYXQgb3BhY2l0eTtcXG59O1xcblxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdExpZ2h0c1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXG5cXHRzdHJ1Y3QgRGlyZWN0aW9uYWxMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBjb2xvcjtcXG5cXHR9O1xcblxcblxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0c1sgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cXHRzdHJ1Y3QgUG9pbnRMaWdodCB7XFxuXFx0XFx0dmVjMyBwb3NpdGlvbjtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdFxcdGZsb2F0IGRpc3RhbmNlO1xcblxcdFxcdGZsb2F0IGRlY2F5O1xcblxcdH07XFxuXFxuXFx0dW5pZm9ybSBQb2ludExpZ2h0IHBvaW50TGlnaHRzWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0RW52TWFwXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcbnVuaWZvcm0gZmxvYXQgZW52TWFwSW50ZW5zaXR5O1xcbnVuaWZvcm0gZmxvYXQgaWJsSW50ZW5zaXR5O1xcbnVuaWZvcm0gZmxvYXQgbWF4TG9kTGV2ZWw7XFxuXFxuI2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXG5cXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRSZWZsZWN0aW9uXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuI2RlZmluZSBSRUZfTUlQTUFQX0xFVkVMIDguMFxcblxcbiNpZmRlZiBSRUZMRUNUUExBTkVcXG5cXG5cXHR1bmlmb3JtIHZlYzMgYTtcXG5cXG5cXHR2ZWMyIGdldFJlZk1pcG1hcFVWKCB2ZWMyIHV2LCBmbG9hdCBsZXZlbCApIHtcXG5cXG5cXHRcXHR2ZWMyIHJ1diA9IHV2O1xcblxcblxcdFxcdGlmKCBsZXZlbCA+IDAuMCApIHtcXG5cXG5cXHRcXHRcXHRydXYueCAqPSAxLjAgLyAoIDMuMCAqICggcG93KCAyLjAsIGxldmVsICkgLyAyLjAgKSApO1xcblxcdFxcdFxcdHJ1di55ICo9IDEuMCAvICggcG93KCAyLjAsIGxldmVsICkgKTtcXG5cXHRcXHRcXHRydXYueSArPSAxLjAgLyAoIHBvdyggMi4wLCBsZXZlbCApICk7XFxuXFx0XFx0XFx0cnV2LnggKz0gMS4wIC8gMS41O1xcblxcdFxcdFxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0cnV2LnggLz0gMS41O1xcblxcdFxcdFxcdFxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcnV2O1xcblxcblxcdH1cXG5cXHRcXG5cXHR2ZWM0IGN1YmljKGZsb2F0IHYpIHtcXG5cXHRcXHR2ZWM0IG4gPSB2ZWM0KDEuMCwgMi4wLCAzLjAsIDQuMCkgLSB2O1xcblxcdFxcdHZlYzQgcyA9IG4gKiBuICogbjtcXG5cXHRcXHRmbG9hdCB4ID0gcy54O1xcblxcdFxcdGZsb2F0IHkgPSBzLnkgLSA0LjAgKiBzLng7XFxuXFx0XFx0ZmxvYXQgeiA9IHMueiAtIDQuMCAqIHMueSArIDYuMCAqIHMueDtcXG5cXHRcXHRmbG9hdCB3ID0gNi4wIC0geCAtIHkgLSB6O1xcblxcdFxcdHJldHVybiB2ZWM0KHgsIHksIHosIHcpO1xcblxcdH1cXG5cXG5cXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzUwMTA4MS9lZmZpY2llbnQtYmljdWJpYy1maWx0ZXJpbmctY29kZS1pbi1nbHNsXFxuXFx0dmVjNCB0ZXh0dXJlQmljdWJpYyhzYW1wbGVyMkQgdCwgdmVjMiB0ZXhDb29yZHMsIHZlYzIgdGV4dHVyZVNpemUpIHtcXG5cXHRcXHR2ZWMyIGludlRleFNpemUgPSAxLjAgLyB0ZXh0dXJlU2l6ZTtcXG5cXHRcXHR0ZXhDb29yZHMgPSB0ZXhDb29yZHMgKiB0ZXh0dXJlU2l6ZSAtIDAuNTtcXG5cXHRcXHR2ZWMyIGZ4eSA9IGZyYWN0KHRleENvb3Jkcyk7XFxuXFx0XFx0dGV4Q29vcmRzIC09IGZ4eTtcXG5cXHRcXHR2ZWM0IHhjdWJpYyA9IGN1YmljKGZ4eS54KTtcXG5cXHRcXHR2ZWM0IHljdWJpYyA9IGN1YmljKGZ4eS55KTtcXG5cXHRcXHR2ZWM0IGMgPSB0ZXhDb29yZHMueHh5eSArIHZlYzIgKC0wLjUsIDEuNSkueHl4eTtcXG5cXHRcXHR2ZWM0IHMgPSB2ZWM0KHhjdWJpYy54eiArIHhjdWJpYy55dywgeWN1YmljLnh6ICsgeWN1YmljLnl3KTtcXG5cXHRcXHR2ZWM0IG9mZnNldCA9IGMgKyB2ZWM0ICh4Y3ViaWMueXcsIHljdWJpYy55dykgLyBzO1xcblxcdFxcdG9mZnNldCAqPSBpbnZUZXhTaXplLnh4eXk7XFxuXFx0XFx0dmVjNCBzYW1wbGUwID0gdGV4dHVyZTJEKHQsIG9mZnNldC54eik7XFxuXFx0XFx0dmVjNCBzYW1wbGUxID0gdGV4dHVyZTJEKHQsIG9mZnNldC55eik7XFxuXFx0XFx0dmVjNCBzYW1wbGUyID0gdGV4dHVyZTJEKHQsIG9mZnNldC54dyk7XFxuXFx0XFx0dmVjNCBzYW1wbGUzID0gdGV4dHVyZTJEKHQsIG9mZnNldC55dyk7XFxuXFx0XFx0ZmxvYXQgc3ggPSBzLnggLyAocy54ICsgcy55KTtcXG5cXHRcXHRmbG9hdCBzeSA9IHMueiAvIChzLnogKyBzLncpO1xcblxcdFxcdHJldHVybiBtaXgoXFxuXFx0XFx0bWl4KHNhbXBsZTMsIHNhbXBsZTIsIHN4KSwgbWl4KHNhbXBsZTEsIHNhbXBsZTAsIHN4KSwgc3kpO1xcblxcdH1cXG5cXG4jZW5kaWZcXG5cXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRTaGFkb3dcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4jaWZkZWYgREVQVEhcXG5cXG5cXHR2YXJ5aW5nIHZlYzIgdkhpZ2hQcmVjaXNpb25aVztcXG5cXHR1bmlmb3JtIGZsb2F0IGNhbWVyYU5lYXI7XFxuXFx0dW5pZm9ybSBmbG9hdCBjYW1lcmFGYXI7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG4jaWYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcblxcdFxcdHN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IHtcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodFNoYWRvdyBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFxuXFx0I2VuZGlmXFxuXFxuXFx0I2RlZmluZSBTSEFET1dfU0FNUExFX0NPVU5UIDRcXG5cXG5cXHR2ZWMyIHBvaXNzb25EaXNrWyBTSEFET1dfU0FNUExFX0NPVU5UIF07XFxuXFxuXFx0dm9pZCBpbml0UG9pc3NvbkRpc2soIGZsb2F0IHNlZWQgKSB7XFxuXFxuXFx0XFx0ZmxvYXQgciA9IDAuMTtcXG5cXHRcXHRmbG9hdCByU3RlcCA9ICgxLjAgLSByKSAvIGZsb2F0KCBTSEFET1dfU0FNUExFX0NPVU5UICk7XFxuXFxuXFx0XFx0ZmxvYXQgYW5nID0gcmFuZG9tKCBnbF9GcmFnQ29vcmQueHkgKiAwLjAxICsgc2luKCB0aW1lICkgKSAqIFRQSSAqIDEuMDtcXG5cXHRcXHRmbG9hdCBhbmdTdGVwID0gKCAoIFRQSSAqIDExLjAgKSAvIGZsb2F0KCBTSEFET1dfU0FNUExFX0NPVU5UICkgKTtcXG5cXHRcXHRcXG5cXHRcXHRmb3IoIGludCBpID0gMDsgaSA8IFNIQURPV19TQU1QTEVfQ09VTlQ7IGkrKyApIHtcXG5cXG5cXHRcXHRcXHRwb2lzc29uRGlza1sgaSBdID0gdmVjMihcXG5cXHRcXHRcXHRcXHRzaW4oIGFuZyApLFxcblxcdFxcdFxcdFxcdGNvcyggYW5nIClcXG5cXHRcXHRcXHQpICogcG93KCByLCAwLjc1ICk7XFxuXFxuXFx0XFx0XFx0ciArPSByU3RlcDtcXG5cXHRcXHRcXHRhbmcgKz0gYW5nU3RlcDtcXG5cXHRcXHR9XFxuXFx0XFx0XFxuXFx0fVxcblxcblxcdHZlYzIgY29tcGFpclNoYWRvd01hcERlcHRoKCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFVWLCBmbG9hdCBkZXB0aCApIHtcXG5cXG5cXHRcXHRpZiggc2hhZG93TWFwVVYueCA8IDAuMCB8fCBzaGFkb3dNYXBVVi54ID4gMS4wIHx8IHNoYWRvd01hcFVWLnkgPCAwLjAgfHwgc2hhZG93TWFwVVYueSA+IDEuMCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdmVjMiggMS4wLCAwLjAgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZmxvYXQgc2hhZG93TWFwRGVwdGggPSB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXAsIHNoYWRvd01hcFVWICkgKTtcXG5cXG5cXHRcXHRpZiggMC4wID49IHNoYWRvd01hcERlcHRoIHx8IHNoYWRvd01hcERlcHRoID49IDEuMCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdmVjMiggMS4wLCAwLjAgKTtcXG5cXG5cXHRcXHR9XFxuXFx0XFx0XFxuXFx0XFx0ZmxvYXQgc2hhZG93ID0gZGVwdGggPD0gc2hhZG93TWFwRGVwdGggPyAxLjAgOiAwLjA7XFxuXFxuXFx0XFx0cmV0dXJuIHZlYzIoIHNoYWRvdywgc2hhZG93TWFwRGVwdGggKTtcXG5cXHRcXHRcXG5cXHR9XFxuXFxuXFx0ZmxvYXQgc2hhZG93TWFwUENGKCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWM0IHNoYWRvd01hcENvb3JkLCB2ZWMyIHNoYWRvd1NpemUgKSB7XFxuXFxuXFx0XFx0ZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcdFxcdFxcblxcdFxcdGZvciggaW50IGkgPSAwOyBpIDwgU0hBRE9XX1NBTVBMRV9DT1VOVDsgaSArKyAgKSB7XFxuXFx0XFx0XFx0XFxuXFx0XFx0XFx0dmVjMiBvZmZzZXQgPSBwb2lzc29uRGlza1sgaSBdICogc2hhZG93U2l6ZTsgXFxuXFxuXFx0XFx0XFx0c2hhZG93ICs9IGNvbXBhaXJTaGFkb3dNYXBEZXB0aCggc2hhZG93TWFwLCBzaGFkb3dNYXBDb29yZC54eSArIG9mZnNldCwgc2hhZG93TWFwQ29vcmQueiApLng7XFxuXFx0XFx0XFx0XFxuXFx0XFx0fVxcblxcblxcdFxcdHNoYWRvdyAvPSBmbG9hdCggU0hBRE9XX1NBTVBMRV9DT1VOVCApO1xcblxcblxcdFxcdHJldHVybiBzaGFkb3c7XFxuXFxuXFx0fVxcblxcblxcdGZsb2F0IGdldFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBiaWFzLCB2ZWM0IHNoYWRvd01hcENvb3JkICkge1xcblxcdFxcdFxcblxcdFxcdHNoYWRvd01hcENvb3JkLnh5eiAvPSBzaGFkb3dNYXBDb29yZC53O1xcblxcdFxcdHNoYWRvd01hcENvb3JkLnogKz0gYmlhcyAtIDAuMDAwMTtcXG5cXG5cXHRcXHRpbml0UG9pc3NvbkRpc2sodGltZSk7XFxuXFxuXFx0XFx0dmVjMiBzaGFkb3dTaXplID0gMS4wIC8gc2hhZG93TWFwU2l6ZTtcXG5cXG5cXHRcXHRyZXR1cm4gc2hhZG93TWFwUENGKCBzaGFkb3dNYXAsIHNoYWRvd01hcENvb3JkLCBzaGFkb3dTaXplICk7XFxuXFxuXFx0fVxcblxcbiNlbmRpZlxcblxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdFJFXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxudmFyeWluZyB2ZWMzIHZWaWV3Tm9ybWFsO1xcbnZhcnlpbmcgdmVjMyB2Vmlld1BvcztcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zO1xcblxcbmZsb2F0IGdneCggZmxvYXQgZE5ILCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0XFxuXFx0ZmxvYXQgYTIgPSByb3VnaG5lc3MgKiByb3VnaG5lc3M7XFxuXFx0YTIgPSBhMiAqIGEyO1xcblxcdGZsb2F0IGROSDIgPSBkTkggKiBkTkg7XFxuXFxuXFx0aWYoIGROSDIgPD0gMC4wICkgcmV0dXJuIDAuMDtcXG5cXG5cXHRyZXR1cm4gYTIgLyAoIFBJICogcG93KCBkTkgyICogKCBhMiAtIDEuMCApICsgMS4wLCAyLjApICk7XFxuXFxufVxcblxcbnZlYzMgbGFtYmVydCggdmVjMyBkaWZmdXNlQ29sb3IgKSB7XFxuXFxuXFx0cmV0dXJuIGRpZmZ1c2VDb2xvciAvIFBJO1xcblxcbn1cXG5cXG5mbG9hdCBnU2NobGljayggZmxvYXQgZCwgZmxvYXQgayApIHtcXG5cXG5cXHRpZiggZCA9PSAwLjAgKSByZXR1cm4gMC4wO1xcblxcblxcdHJldHVybiBkIC8gKCBkICogKCAxLjAgLSBrICkgKyBrICk7XFxuXFx0XFxufVxcblxcbmZsb2F0IGdTbWl0aCggZmxvYXQgZE5WLCBmbG9hdCBkTkwsIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXG5cXHRmbG9hdCBrID0gY2xhbXAoIHJvdWdobmVzcyAqIHNxcnQoIDIuMCAvIFBJICksIDAuMCwgMS4wICk7XFxuXFxuXFx0cmV0dXJuIGdTY2hsaWNrKCBkTlYsIGsgKSAqIGdTY2hsaWNrKCBkTkwsIGsgKTtcXG5cXHRcXG59XFxuXFxuZmxvYXQgZnJlc25lbCggZmxvYXQgZCApIHtcXG5cXHRcXG5cXHRmbG9hdCBmMCA9IDAuMDQ7XFxuXFxuXFx0cmV0dXJuIGYwICsgKCAxLjAgLSBmMCApICogcG93KCAxLjAgLSBkLCA1LjAgKTtcXG5cXG59XFxuXFxudmVjMyBSRSggR2VvbWV0cnkgZ2VvLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0KSB7XFxuXFxuXFx0dmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0dmVjMyBoYWxmVmVjID0gbm9ybWFsaXplKCBnZW8udmlld0RpciArIGxpZ2h0RGlyICk7XFxuXFxuXFx0ZmxvYXQgZExIID0gY2xhbXAoIGRvdCggbGlnaHREaXIsIGhhbGZWZWMgKSwgMC4wLCAxLjAgKTtcXG5cXHRmbG9hdCBkTkggPSBjbGFtcCggZG90KCBnZW8ubm9ybWFsLCBoYWxmVmVjICksIDAuMCwgMS4wICk7XFxuXFx0ZmxvYXQgZE5WID0gY2xhbXAoIGRvdCggZ2VvLm5vcm1hbCwgZ2VvLnZpZXdEaXIgKSwgMC4wLCAxLjAgKTtcXG5cXHRmbG9hdCBkTkwgPSBjbGFtcCggZG90KCBnZW8ubm9ybWFsLCBsaWdodERpciksIDAuMCwgMS4wICk7XFxuXFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gbGlnaHQuY29sb3IgKiBkTkw7XFxuXFxuXFx0Ly8gZGlmZnVzZVxcblxcdHZlYzMgZGlmZnVzZSA9IGxhbWJlcnQoIG1hdC5kaWZmdXNlQ29sb3IgKSAqIGlycmFkaWFuY2U7XFxuXFxuXFx0Ly8gc3BlY3VsYXJcXG5cXHRmbG9hdCBEID0gZ2d4KCBkTkgsIG1hdC5yb3VnaG5lc3MgKTtcXG5cXHRmbG9hdCBHID0gZ1NtaXRoKCBkTlYsIGROTCwgbWF0LnJvdWdobmVzcyApO1xcblxcdGZsb2F0IEYgPSBmcmVzbmVsKCBkTEggKTtcXG5cXHRcXG5cXHR2ZWMzIHNwZWN1bGFyID0gKCggRCAqIEcgKiBGICkgLyAoIDQuMCAqIGROTCAqIGROViArIDAuMDAwMSApICogbWF0LnNwZWN1bGFyQ29sb3IgKSAqIGlycmFkaWFuY2U7IFxcblxcblxcdHZlYzMgYyA9IHZlYzMoIDAuMCApO1xcblxcdGMgKz0gZGlmZnVzZSAqICggMS4wIC0gRiApICsgc3BlY3VsYXI7XFxuXFxuXFx0cmV0dXJuIGM7XFxuXFxufVxcblxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdE1haW5cXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG52b2lkIG1haW4oIHZvaWQgKSB7XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0TWF0ZXJpYWxcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHRNYXRlcmlhbCBtYXQ7XFxuXFxuXFx0I2lmZGVmIFVTRV9NQVBcXG5cXG5cXHRcXHR2ZWM0IGNvbG9yID0gTGluZWFyVG9zUkdCKCB0ZXh0dXJlMkQoIG1hcCwgdlV2ICkgKTtcXG5cXHRcXHRtYXQuYWxiZWRvID0gY29sb3IueHl6O1xcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0bWF0LmFsYmVkbyA9IGNvbG9yLnh5ejtcXG5cXHRcXHRtYXQub3BhY2l0eSA9IDEuMDtcXG5cXHRcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWZkZWYgVVNFX1JPVUdITkVTU19NQVBcXG5cXG5cXHRcXHRtYXQucm91Z2huZXNzID0gdGV4dHVyZTJEKCByb3VnaG5lc3NNYXAsIHZVdiApLnk7XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHRtYXQucm91Z2huZXNzID0gcm91Z2huZXNzO1xcblxcdFxcblxcdCNlbmRpZlxcblxcblxcdCNpZmRlZiBVU0VfTUVUQUxORVNTX01BUFxcblxcblxcdFxcdG1hdC5tZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdlV2ICkuejtcXG5cXG5cXHQjZWxzZVxcblxcblxcdFxcdG1hdC5tZXRhbG5lc3MgPSBtZXRhbG5lc3M7XFxuXFx0XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIFVTRV9BTFBIQV9NQVBcXG5cXG5cXHRcXHRtYXQub3BhY2l0eSA9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLng7XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHRtYXQub3BhY2l0eSA9IG9wYWNpdHk7XFxuXFxuXFx0I2VuZGlmXFxuXFx0XFxuXFx0aWYoIG1hdC5vcGFjaXR5IDwgMC41ICkgZGlzY2FyZDtcXG5cXG5cXHRtYXQuZGlmZnVzZUNvbG9yID0gbWl4KCBtYXQuYWxiZWRvLCB2ZWMzKCAwLjAsIDAuMCwgMC4wICksIG1hdC5tZXRhbG5lc3MgKTtcXG5cXHRtYXQuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggMS4wLCAxLjAsIDEuMCApLCBtYXQuYWxiZWRvLCBtYXQubWV0YWxuZXNzICk7XFxuXFxuXFx0Ly8gb3V0cHV0XFxuXFx0dmVjMyBvdXRDb2xvciA9IHZlYzMoIDAuMCApO1xcblxcdGZsb2F0IG91dE9wYWNpdHkgPSBtYXQub3BhY2l0eTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHREZXB0aFxcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdCNpZmRlZiBERVBUSFxcblxcblxcdFxcdGZsb2F0IGZyYWdDb29yZFogPSAwLjUgKiB2SGlnaFByZWNpc2lvblpXLnggLyB2SGlnaFByZWNpc2lvblpXLnkgKyAwLjU7XFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBmcmFnQ29vcmRaICk7XFxuXFx0XFx0cmV0dXJuO1xcblxcdFxcblxcdCNlbmRpZlxcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdFxcdEdlb21ldHJ5XFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuXFx0ZmxvYXQgZmFjZURpcmVjdGlvbiA9IGdsX0Zyb250RmFjaW5nID8gMS4wIDogLTEuMDtcXG5cXG5cXHRHZW9tZXRyeSBnZW87XFxuXFx0Z2VvLnBvcyA9IC12Vmlld1BvcztcXG5cXHRnZW8ucG9zV29ybGQgPSB2V29ybGRQb3M7XFxuXFx0Z2VvLnZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zICk7XFxuXFx0Z2VvLnZpZXdEaXJXb3JsZCA9IG5vcm1hbGl6ZSggZ2VvLnBvc1dvcmxkIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXHRnZW8ubm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICkgKiBmYWNlRGlyZWN0aW9uO1xcblxcblxcdCNpZmRlZiBVU0VfTk9STUFMX01BUFxcblxcdFxcdFxcblxcdFxcdHZlYzMgdGFuZ2VudCA9IG5vcm1hbGl6ZSggdlRhbmdlbnQgKTtcXG5cXHRcXHR2ZWMzIGJpdGFuZ2VudCA9IG5vcm1hbGl6ZSggdkJpdGFuZ2VudCApO1xcblxcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cXHRcXHRcXHR0YW5nZW50ICo9IGZhY2VEaXJlY3Rpb247XFxuXFx0XFx0XFx0Yml0YW5nZW50ICo9IGZhY2VEaXJlY3Rpb247XFxuXFx0XFx0XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0XFxuXFx0XFx0bWF0MyB2VEJOID0gbWF0MyggdGFuZ2VudCwgYml0YW5nZW50LCBnZW8ubm9ybWFsICk7XFxuXFx0XFx0XFxuXFx0XFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5ejtcXG5cXHRcXHRtYXBOID0gbWFwTiAqIDIuMCAtIDEuMDtcXG5cXHRcXHRnZW8ubm9ybWFsID0gbm9ybWFsaXplKCB2VEJOICogbWFwTiApO1xcblxcblxcdCNlbmRpZlxcblxcdFxcblxcdGdlby5ub3JtYWxXb3JsZCA9IG5vcm1hbGl6ZSggKCB2ZWM0KCBnZW8ubm9ybWFsLCAwLjAgKSAqIHZpZXdNYXRyaXggKS54eXogKTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHRMaWdodGluZ1xcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcdFxcblxcdExpZ2h0IGxpZ2h0O1xcblxcblxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX3N0YXJ0XFxuXFx0XFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXS5kaXJlY3Rpb247XFxuXFx0XFx0XFx0XFx0bGlnaHQuY29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdLmNvbG9yO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXG5cXHRcXHRcXHRcXHRcXG5cXHRcXHRcXHRcXHQjaWYgZGVmaW5lZCggVVNFX1NIQURPV01BUCApICYmIE5VTV9ESVJfTElHSFRfU0hBRE9XUyA+IDBcXG5cXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3cgPSBnZXRTaGFkb3coIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBpIF0sIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBpIF0uc2hhZG93TWFwU2l6ZSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dCaWFzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0XFx0b3V0Q29sb3IgKz0gUkUoIGdlbywgbWF0LCBsaWdodCApICogc2hhZG93O1xcblxcdFxcdFxcdFxcdFxcblxcdFxcdFxcdH1cXG5cXHRcXHQjcHJhZ21hIHVucm9sbF9sb29wX2VuZFxcblxcblxcdCNlbmRpZlxcblxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcblxcdFxcdFBvaW50TGlnaHQgcExpZ2h0O1xcblxcdFxcdHZlYzMgdjtcXG5cXHRcXHRmbG9hdCBkO1xcblxcdFxcdGZsb2F0IGF0dGVudWF0aW9uO1xcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXG5cXHRcXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHBMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0diA9IHBMaWdodC5wb3NpdGlvbiAtIGdlby5wb3M7XFxuXFx0XFx0XFx0XFx0ZCA9IGxlbmd0aCggdiApO1xcblxcdFxcdFxcdFxcdGxpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdiApO1xcblxcdFxcdFxcblxcdFxcdFxcdFxcdGxpZ2h0LmNvbG9yID0gcExpZ2h0LmNvbG9yO1xcblxcblxcdFxcdFxcdFxcdGlmKCBwTGlnaHQuZGlzdGFuY2UgPiAwLjAgJiYgcExpZ2h0LmRlY2F5ID4gMC4wICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGF0dGVudWF0aW9uID0gcG93KCBjbGFtcCggLWQgLyBwTGlnaHQuZGlzdGFuY2UgKyAxLjAsIDAuMCwgMS4wICksIHBMaWdodC5kZWNheSApO1xcblxcdFxcdFxcdFxcdFxcdGxpZ2h0LmNvbG9yICo9IGF0dGVudWF0aW9uO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRvdXRDb2xvciArPSBSRSggZ2VvLCBtYXQsIGxpZ2h0ICk7XFxuXFx0XFx0XFx0XFx0XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFxuXFx0I2VuZGlmXFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0RW52aXJvbm1lbnQgTGlnaHRpbmdcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHRmbG9hdCBkTlYgPSBjbGFtcCggZG90KCBnZW8ubm9ybWFsLCBnZW8udmlld0RpciApLCAwLjAsIDEuMCApO1xcblxcblxcdHZlYzMgcmVmRGlyID0gcmVmbGVjdCggZ2VvLnZpZXdEaXJXb3JsZCwgZ2VvLm5vcm1hbFdvcmxkICk7XFxuXFx0cmVmRGlyLnggKj0gLTEuMDtcXG5cXG5cXHR2ZWM0IGVudk1hcENvbG9yID0gTGluZWFyVG9zUkdCKCB0ZXh0dXJlQ3ViZVVWKCBlbnZNYXAsIGdlby5ub3JtYWxXb3JsZCwgMS4wICkgKSAqIGlibEludGVuc2l0eSAqIGVudk1hcEludGVuc2l0eTtcXG5cXHRvdXRDb2xvciArPSBtYXQuZGlmZnVzZUNvbG9yICogZW52TWFwQ29sb3IueHl6ICogKCAxLjAgLSBtYXQubWV0YWxuZXNzICk7XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0UmVmbGVjdGlvblxcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcdFxcblxcdGZsb2F0IEVGID0gbWl4KCBmcmVzbmVsKCBkTlYgKSwgMS4wLCBtYXQubWV0YWxuZXNzICk7XFxuXFxuXFx0I2lmZGVmIFJFRkxFQ1RQTEFORVxcblxcdFxcblxcdFxcdHZlYzIgcmVmVVYgPSBnbF9GcmFnQ29vcmQueHkgLyByZW5kZXJSZXNvbHV0aW9uO1xcblxcblxcdFxcdHJlZlVWLnggKz0gZ2VvLm5vcm1hbC54ICogMC41O1xcblxcblxcdFxcdGZsb2F0IGwgPSAoMS4wIC0gZXhwKCAtbWF0LnJvdWdobmVzcyAgKSApICogMS42ICogUkVGX01JUE1BUF9MRVZFTDtcXG5cXG5cXHRcXHRmbG9hdCBvZmZzZXQxID0gZmxvb3IoIGwgKTtcXG5cXHRcXHRmbG9hdCBvZmZzZXQyID0gb2Zmc2V0MSArIDEuMDtcXG5cXHRcXHRmbG9hdCBibGVuZCA9IGZyYWN0KCBsICk7XFxuXFx0XFx0XFxuXFx0XFx0dmVjMiBydXYxID0gZ2V0UmVmTWlwbWFwVVYoIHJlZlVWLCBvZmZzZXQxICk7XFxuXFx0XFx0dmVjMiBydXYyID0gZ2V0UmVmTWlwbWFwVVYoIHJlZlVWLCBvZmZzZXQyICk7XFxuXFxuXFx0XFx0dmVjMyByZWYxID0gdGV4dHVyZUJpY3ViaWMoIHJlZmxlY3Rpb25UZXgsIHJ1djEsIG1pcE1hcFJlc29sdXRpb24gKS54eXo7XFxuXFx0XFx0dmVjMyByZWYyID0gdGV4dHVyZUJpY3ViaWMoIHJlZmxlY3Rpb25UZXgsIHJ1djIsIG1pcE1hcFJlc29sdXRpb24gKS54eXo7XFxuXFxuXFx0XFx0b3V0Q29sb3IgKz0gbWl4KCByZWYxLCByZWYyLCBibGVuZCApICogRUY7XFxuXFxuXFx0I2Vsc2VcXG5cXHRcXG5cXHRcXHRvdXRDb2xvciArPSBtYXQuc3BlY3VsYXJDb2xvciAqIExpbmVhclRvc1JHQiggdGV4dHVyZUN1YmVVViggZW52TWFwLCByZWZEaXIsIG1hdC5yb3VnaG5lc3MgKSApLnh5eiAqIEVGICogZW52TWFwSW50ZW5zaXR5O1xcblxcdFxcblxcdCNlbmRpZlxcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdFxcdEVtaXNzaW9uXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuXFx0I2lmZGVmIFVTRV9FTUlTU0lPTl9NQVBcXG5cXG5cXHRcXHRvdXRDb2xvciArPSBMaW5lYXJUb3NSR0IoIHRleHR1cmUyRCggZW1pc3Npb25NYXAsIHZVdiApICkueHl6O1xcblxcdFxcblxcdCNlbHNlXFxuXFxuXFx0XFx0b3V0Q29sb3IgKz0gZW1pc3Npb247XFxuXFxuXFx0I2VuZGlmXFxuXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Q29sb3IsIG91dE9wYWNpdHkgKTtcXG5cXG59XCI7IiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xyXG5pbXBvcnQgKiBhcyBPUkUgZnJvbSAnb3JlLXRocmVlLXRzJztcclxuXHJcbmltcG9ydCBwb3dlclZlcnQgZnJvbSAnLi9zaGFkZXJzL3Bvd2VyLnZzJztcclxuaW1wb3J0IHBvd2VyRnJhZyBmcm9tICcuL3NoYWRlcnMvcG93ZXIuZnMnO1xyXG5cclxuZXhwb3J0IHR5cGUgUG93ZXJNZXNoTWF0ZXJpYWxUeXBlID0gJ2NvbG9yJyB8ICdkZXB0aCcgfCAnY29jJ1xyXG5leHBvcnQgY2xhc3MgUG93ZXJNZXNoIGV4dGVuZHMgVEhSRUUuTWVzaDxUSFJFRS5CdWZmZXJHZW9tZXRyeSwgVEhSRUUuU2hhZGVyTWF0ZXJpYWw+IHtcclxuXHJcblx0cHJvdGVjdGVkIGNvbW1vblVuaWZvcm1zOiBPUkUuVW5pZm9ybXM7XHJcblxyXG5cdC8vIGVudk1hcFxyXG5cdHByb3RlY3RlZCBlbnZNYXBSZW5kZXJUYXJnZXQ6IFRIUkVFLldlYkdMQ3ViZVJlbmRlclRhcmdldDtcclxuXHRwcm90ZWN0ZWQgZW52TWFwQ2FtZXJhOiBUSFJFRS5DdWJlQ2FtZXJhO1xyXG5cdHByb3RlY3RlZCBlbnZNYXBVcGRhdGU6IGJvb2xlYW47XHJcblx0cHJvdGVjdGVkIGVudk1hcFNyYzogVEhSRUUuQ3ViZVRleHR1cmUgfCBUSFJFRS5UZXh0dXJlIHwgbnVsbDtcclxuXHJcblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5OiBUSFJFRS5CdWZmZXJHZW9tZXRyeSwgbWF0ZXJpYWxPcHRpb24/OiBUSFJFRS5TaGFkZXJNYXRlcmlhbFBhcmFtZXRlcnMgKTtcclxuXHJcblx0Y29uc3RydWN0b3IoIG1lc2g6IFRIUkVFLk1lc2gsIG1hdGVyaWFsT3B0aW9uPzogVEhSRUUuU2hhZGVyTWF0ZXJpYWxQYXJhbWV0ZXJzICk7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBnZW9NZXNoOiBUSFJFRS5CdWZmZXJHZW9tZXRyeSB8IFRIUkVFLk1lc2gsIG1hdGVyaWFsT3B0aW9uPzogVEhSRUUuU2hhZGVyTWF0ZXJpYWxQYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdG1hdGVyaWFsT3B0aW9uID0gbWF0ZXJpYWxPcHRpb24gfHwge307XHJcblxyXG5cdFx0bGV0IHVuaSA9IE9SRS5Vbmlmb3Jtc0xpYi5tZXJnZVVuaWZvcm1zKCBtYXRlcmlhbE9wdGlvbi51bmlmb3JtcyB8fCB7fSwge1xyXG5cdFx0XHRlbnZNYXA6IHtcclxuXHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRlbnZNYXBJbnRlbnNpdHk6IHtcclxuXHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRpYmxJbnRlbnNpdHk6IHtcclxuXHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRtYXhMb2RMZXZlbDoge1xyXG5cdFx0XHRcdHZhbHVlOiAwXHJcblx0XHRcdH0sXHJcblx0XHRcdHNoYWRvd0xpZ2h0TW9kZWxWaWV3TWF0cml4OiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5NYXRyaXg0KClcclxuXHRcdFx0fSxcclxuXHRcdFx0c2hhZG93TGlnaHRQcm9qZWN0aW9uTWF0cml4OiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5NYXRyaXg0KClcclxuXHRcdFx0fSxcclxuXHRcdFx0c2hhZG93TGlnaHREaXJlY3Rpb246IHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjMoKVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzaGFkb3dMaWdodENhbWVyYUNsaXA6IHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoKVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzaGFkb3dNYXA6IHtcclxuXHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzaGFkb3dNYXBTaXplOiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKClcclxuXHRcdFx0fSxcclxuXHRcdFx0c2hhZG93TWFwUmVzb2x1dGlvbjoge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMigpXHJcblx0XHRcdH0sXHJcblx0XHRcdHNoYWRvd0xpZ2h0U2l6ZToge1xyXG5cdFx0XHRcdHZhbHVlOiAxLjBcclxuXHRcdFx0fSxcclxuXHRcdFx0Y2FtZXJhTmVhcjoge1xyXG5cdFx0XHRcdHZhbHVlOiAwLjAxXHJcblx0XHRcdH0sXHJcblx0XHRcdGNhbWVyYUZhcjoge1xyXG5cdFx0XHRcdHZhbHVlOiAxMDAwLjBcclxuXHRcdFx0fVxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHVuaSA9IE9SRS5Vbmlmb3Jtc0xpYi5tZXJnZVVuaWZvcm1zKCB1bmksIFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIFRIUkVFLlVuaWZvcm1zTGliLmxpZ2h0cyApICk7XHJcblxyXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdEdlb21ldHJ5XHJcblx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0XHRsZXQgZ2VvOiBUSFJFRS5CdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0XHRpZiAoICdpc0J1ZmZlckdlb21ldHJ5JyBpbiBnZW9NZXNoICkge1xyXG5cclxuXHRcdFx0Z2VvID0gZ2VvTWVzaDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCAnaXNNZXNoJyBpbiBnZW9NZXNoICkge1xyXG5cclxuXHRcdFx0Z2VvID0gZ2VvTWVzaC5nZW9tZXRyeTtcclxuXHJcblx0XHRcdGxldCBtYXQgPSAoIGdlb01lc2gubWF0ZXJpYWwgYXMgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdGlmICggbWF0LmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0Lm1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmkubWFwID0ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF0Lm1hcFxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0LmNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaS5jb2xvciA9IHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IG1hdC5jb2xvclxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG1hdC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pLnJvdWdobmVzc01hcCA9IHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IG1hdC5yb3VnaG5lc3NNYXBcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pLnJvdWdobmVzcyA9IHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IG1hdC5yb3VnaG5lc3NcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXQuYWxwaGFNYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pLmFscGhhTWFwID0ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF0LmFscGhhTWFwXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHVuaS5vcGFjaXR5ID0ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF0Lm9wYWNpdHlcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXQubWV0YWxuZXNzTWFwICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaS5tZXRhbG5lc3NNYXAgPSB7XHJcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXQubWV0YWxuZXNzTWFwXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHVuaS5tZXRhbG5lc3MgPSB7XHJcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXQubWV0YWxuZXNzXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggbWF0Lm5vcm1hbE1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmkubm9ybWFsTWFwID0ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF0Lm5vcm1hbE1hcFxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG1hdC5lbWlzc2l2ZU1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmkuZW1pc3Npb25NYXAgPSB7XHJcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXQuZW1pc3NpdmVNYXBcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pLmVtaXNzaW9uID0ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF0LmVtaXNzaXZlXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGdlbyA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB0YW5nZW50c1xyXG5cclxuXHRcdGlmICggISBnZW8uZ2V0QXR0cmlidXRlKCAndGFuZ2VudCcgKSApIHtcclxuXHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHRnZW8uZ2V0SW5kZXgoKSAmJlxyXG5cdFx0XHRcdGdlby5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKSAmJlxyXG5cdFx0XHRcdGdlby5nZXRBdHRyaWJ1dGUoICdub3JtYWwnICkgJiZcclxuXHRcdFx0XHRnZW8uZ2V0QXR0cmlidXRlKCAndXYnIClcclxuXHRcdFx0KSB7XHJcblxyXG5cdFx0XHRcdGdlby5jb21wdXRlVGFuZ2VudHMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdE1hdGVyaWFsXHJcblx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0XHRtYXRlcmlhbE9wdGlvbi51bmlmb3JtcyA9IHVuaTtcclxuXHJcblx0XHRsZXQgbWF0ID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XHJcblx0XHRcdHZlcnRleFNoYWRlcjogcG93ZXJWZXJ0LFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogcG93ZXJGcmFnLFxyXG5cdFx0XHRsaWdodHM6IHRydWUsXHJcblx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG5cdFx0XHRzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxyXG5cdFx0XHRleHRlbnNpb25zOiB7XHJcblx0XHRcdFx0ZGVyaXZhdGl2ZXM6IHRydWUsXHJcblx0XHRcdH0sXHJcblx0XHRcdGRlZmluZXM6IHtcclxuXHRcdFx0fSxcclxuXHRcdFx0Li4ubWF0ZXJpYWxPcHRpb25cclxuXHRcdH0gKTtcclxuXHJcblx0XHRpZiAoIHVuaS5tYXAgKSB7XHJcblxyXG5cdFx0XHRtYXQuZGVmaW5lcy5VU0VfTUFQID0gJyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdW5pLnJvdWdobmVzc01hcCApIHtcclxuXHJcblx0XHRcdG1hdC5kZWZpbmVzLlVTRV9ST1VHSE5FU1NfTUFQID0gJyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdW5pLm1ldGFsbmVzc01hcCApIHtcclxuXHJcblx0XHRcdG1hdC5kZWZpbmVzLlVTRV9NRVRBTE5FU1NfTUFQID0gJyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdW5pLmFscGhhTWFwICkge1xyXG5cclxuXHRcdFx0bWF0LmRlZmluZXMuVVNFX0FMUEhBX01BUCA9ICcnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVuaS5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHRtYXQuZGVmaW5lcy5VU0VfTk9STUFMX01BUCA9ICcnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVuaS5lbWlzc2lvbk1hcCApIHtcclxuXHJcblx0XHRcdG1hdC5kZWZpbmVzLlVTRV9FTUlTU0lPTl9NQVAgPSAnJztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3VwZXIoIGdlbywgbWF0ICk7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gZ2VvTWVzaC5uYW1lO1xyXG5cclxuXHRcdHRoaXMudXNlckRhdGEuY29sb3JNYXQgPSB0aGlzLm1hdGVyaWFsO1xyXG5cclxuXHRcdHRoaXMuY3VzdG9tRGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHBvd2VyVmVydCxcclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHBvd2VyRnJhZyxcclxuXHRcdFx0c2lkZTogVEhSRUUuRG91YmxlU2lkZSxcclxuXHRcdFx0bGlnaHRzOiB0cnVlLFxyXG5cdFx0XHRleHRlbnNpb25zOiB7XHJcblx0XHRcdFx0ZGVyaXZhdGl2ZXM6IHRydWVcclxuXHRcdFx0fSxcclxuXHRcdFx0Li4ubWF0ZXJpYWxPcHRpb24sXHJcblx0XHRcdGRlZmluZXM6IHtcclxuXHRcdFx0XHQuLi5tYXQuZGVmaW5lcyxcclxuXHRcdFx0XHQnREVQVEgnOiBcIlwiLFxyXG5cdFx0XHR9LFxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHRoaXMuY29tbW9uVW5pZm9ybXMgPSB1bmk7XHJcblxyXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdFRyYW5zZm9ybVxyXG5cdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdFx0aWYgKCAnaXNNZXNoJyBpbiBnZW9NZXNoICkge1xyXG5cclxuXHRcdFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBnZW9NZXNoLnBvc2l0aW9uICk7XHJcblx0XHRcdHRoaXMucm90YXRpb24uY29weSggZ2VvTWVzaC5yb3RhdGlvbiApO1xyXG5cdFx0XHR0aGlzLnNjYWxlLmNvcHkoIGdlb01lc2guc2NhbGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdEVudk1hcFxyXG5cdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdFx0dGhpcy5lbnZNYXBTcmMgPSBudWxsO1xyXG5cdFx0dGhpcy5lbnZNYXBVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRsZXQgZW52TWFwUmVzb2x1dGlvbiA9IDI1NjtcclxuXHJcblx0XHR0aGlzLmVudk1hcFJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTEN1YmVSZW5kZXJUYXJnZXQoIGVudk1hcFJlc29sdXRpb24sIHtcclxuXHRcdFx0Zm9ybWF0OiBUSFJFRS5SR0JBRm9ybWF0LFxyXG5cdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IHRydWUsXHJcblx0XHRcdG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlclxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHRoaXMuZW52TWFwQ2FtZXJhID0gbmV3IFRIUkVFLkN1YmVDYW1lcmEoIDAuMDAxLCAxMDAwLCB0aGlzLmVudk1hcFJlbmRlclRhcmdldCApO1xyXG5cdFx0dGhpcy5nZXRXb3JsZFBvc2l0aW9uKCB0aGlzLmVudk1hcENhbWVyYS5wb3NpdGlvbiApO1xyXG5cclxuXHRcdHRoaXMub25CZWZvcmVSZW5kZXIgPSAoIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhICkgPT4ge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7XHJcblx0XHRcdFx0dHlwZTogJ2JlZm9yZVJlbmRlcicsXHJcblx0XHRcdFx0cmVuZGVyZXIsXHJcblx0XHRcdFx0c2NlbmUsXHJcblx0XHRcdFx0Y2FtZXJhXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggJ2JlZm9yZVJlbmRlcicsICggZTogVEhSRUUuRXZlbnQgKSA9PiB7XHJcblxyXG5cdFx0XHRsZXQgcmVuZGVyZXIgPSBlLnJlbmRlcmVyO1xyXG5cdFx0XHRsZXQgc2NlbmUgPSBlLnNjZW5lO1xyXG5cdFx0XHRsZXQgY2FtZXJhID0gZS5jYW1lcmE7XHJcblxyXG5cdFx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFx0XHRFbnZNYXBcclxuXHRcdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZW52TWFwVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRsZXQgZW52TWFwUlQ6IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0IHwgbnVsbCA9IG51bGw7XHJcblxyXG5cdFx0XHRcdGxldCBwbXJlbUdlbmVyYXRvciA9IG5ldyBUSFJFRS5QTVJFTUdlbmVyYXRvciggcmVuZGVyZXIgKTtcclxuXHRcdFx0XHRwbXJlbUdlbmVyYXRvci5jb21waWxlRXF1aXJlY3Rhbmd1bGFyU2hhZGVyKCk7XHJcblxyXG5cdFx0XHRcdGlmICggdGhpcy5lbnZNYXBTcmMgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAnaXNDdWJlVGV4dHVyZScgaW4gdGhpcy5lbnZNYXBTcmMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRlbnZNYXBSVCA9IHBtcmVtR2VuZXJhdG9yLmZyb21DdWJlbWFwKCB0aGlzLmVudk1hcFNyYyApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRlbnZNYXBSVCA9IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIoIHRoaXMuZW52TWFwU3JjICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuZW52TWFwQ2FtZXJhLnVwZGF0ZSggcmVuZGVyZXIsIHNjZW5lICk7XHJcblx0XHRcdFx0XHRlbnZNYXBSVCA9IHBtcmVtR2VuZXJhdG9yLmZyb21DdWJlbWFwKCB0aGlzLmVudk1hcFJlbmRlclRhcmdldC50ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmNvbW1vblVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IGVudk1hcFJULnRleHR1cmU7XHJcblx0XHRcdFx0dGhpcy5lbnZNYXBVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdFx0XHRcdERlcHRoXHJcblx0XHRcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuXHRcdFx0aWYgKCBjYW1lcmEudXNlckRhdGEuZGVwdGhDYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubWF0ZXJpYWwgPSB0aGlzLnVzZXJEYXRhLmRlcHRoTWF0O1xyXG5cdFx0XHRcdHRoaXMuY29tbW9uVW5pZm9ybXMuY2FtZXJhTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xyXG5cdFx0XHRcdHRoaXMuY29tbW9uVW5pZm9ybXMuY2FtZXJhRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcclxuXHJcblx0XHRcdFx0aWYgKCAhIHRoaXMubWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdFx0XHRcdFNoYWRvd01hcCBEZXB0aFxyXG5cdFx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0XHRcdC8vIGlmICggY2FtZXJhLnVzZXJEYXRhLnNoYWRvd0NhbWVyYSApIHtcclxuXHJcblx0XHRcdC8vIFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5zaGFkb3dNYXAudmFsdWUgPSBjYW1lcmEudXNlckRhdGEuc2hhZG93TWFwLnZhbHVlO1xyXG5cdFx0XHQvLyBcdHRoaXMuY29tbW9uVW5pZm9ybXMuc2hhZG93TWFwU2l6ZS52YWx1ZSA9IGNhbWVyYS51c2VyRGF0YS5zaGFkb3dNYXBTaXplO1xyXG5cclxuXHRcdFx0Ly8gXHR0aGlzLmNvbW1vblVuaWZvcm1zLnNoYWRvd0xpZ2h0TW9kZWxWaWV3TWF0cml4LnZhbHVlLmNvcHkoIG5ldyBUSFJFRS5NYXRyaXg0KCkubXVsdGlwbHkoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKS5tdWx0aXBseSggdGhpcy5tYXRyaXhXb3JsZCApICk7XHJcblx0XHRcdC8vIFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5zaGFkb3dMaWdodFByb2plY3Rpb25NYXRyaXgudmFsdWUuY29weSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdC8vIFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5zaGFkb3dMaWdodFNpemUudmFsdWUgPSBjYW1lcmEudXNlckRhdGEuc2hhZG93TGlnaHRTaXplO1xyXG5cdFx0XHQvLyBcdGNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbiggdGhpcy5jb21tb25Vbmlmb3Jtcy5zaGFkb3dMaWdodERpcmVjdGlvbi52YWx1ZSApO1xyXG5cdFx0XHQvLyBcdHRoaXMuY29tbW9uVW5pZm9ybXMuc2hhZG93TGlnaHRDYW1lcmFDbGlwLnZhbHVlLmNvcHkoIGNhbWVyYS51c2VyRGF0YS5zaGFkb3dMaWdodENhbWVyYUNsaXAgKTtcclxuXHJcblx0XHRcdC8vIH1cclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdERpc3Bvc2VcclxuXHRcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuXHRcdGNvbnN0IG9uRGlzcG9zZSA9ICgpID0+IHtcclxuXHJcblx0XHRcdHRoaXMuZW52TWFwUmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcclxuXHRcdFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblx0XHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uRGlzcG9zZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdFx0RW52TWFwIC8gSUJMXHJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdHB1YmxpYyB1cGRhdGVFbnZNYXAoIGVudk1hcDogVEhSRUUuQ3ViZVRleHR1cmUgfCBUSFJFRS5UZXh0dXJlIHwgbnVsbCA9IG51bGwgKSB7XHJcblxyXG5cdFx0dGhpcy5lbnZNYXBTcmMgPSBlbnZNYXA7XHJcblx0XHR0aGlzLmVudk1hcFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNvbW1vblVuaWZvcm1zLmVudk1hcEludGVuc2l0eS52YWx1ZSA9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5lbnZNYXBJbnRlbnNpdHkudmFsdWUgPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuY29tbW9uVW5pZm9ybXMuaWJsSW50ZW5zaXR5LnZhbHVlID09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvbW1vblVuaWZvcm1zLmlibEludGVuc2l0eS52YWx1ZSA9IDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXQgZW52TWFwSW50ZW5zaXR5KCB2YWx1ZTogbnVtYmVyICkge1xyXG5cclxuXHRcdHRoaXMuY29tbW9uVW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0cHVibGljIHNldCBpYmxJbnRlbnNpdHkoIHZhbHVlOiBudW1iZXIgKSB7XHJcblxyXG5cdFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5pYmxJbnRlbnNpdHkudmFsdWUgPSB2YWx1ZTtcclxuXHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZGlzcG9zZSgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bzb2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0IGlzUG93ZXJNZXNoKCkge1xyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbiJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwic2VsZiIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM4MV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNjQ0X18iLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJ1bmRlZmluZWQiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiZCIsImRlZmluaXRpb24iLCJrZXkiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwib2JqIiwicHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwiUG93ZXJNZXNoIiwiY29uc3RydWN0b3IiLCJnZW9NZXNoIiwibWF0ZXJpYWxPcHRpb24iLCJnZW8iLCJ1bmkiLCJ1bmlmb3JtcyIsImVudk1hcCIsImVudk1hcEludGVuc2l0eSIsImlibEludGVuc2l0eSIsIm1heExvZExldmVsIiwic2hhZG93TGlnaHRNb2RlbFZpZXdNYXRyaXgiLCJzaGFkb3dMaWdodFByb2plY3Rpb25NYXRyaXgiLCJzaGFkb3dMaWdodERpcmVjdGlvbiIsInNoYWRvd0xpZ2h0Q2FtZXJhQ2xpcCIsInNoYWRvd01hcCIsInNoYWRvd01hcFNpemUiLCJzaGFkb3dNYXBSZXNvbHV0aW9uIiwic2hhZG93TGlnaHRTaXplIiwiY2FtZXJhTmVhciIsImNhbWVyYUZhciIsImdlb21ldHJ5IiwibWF0IiwibWF0ZXJpYWwiLCJpc01lc2hTdGFuZGFyZE1hdGVyaWFsIiwibWFwIiwiY29sb3IiLCJyb3VnaG5lc3NNYXAiLCJyb3VnaG5lc3MiLCJhbHBoYU1hcCIsIm9wYWNpdHkiLCJtZXRhbG5lc3NNYXAiLCJtZXRhbG5lc3MiLCJub3JtYWxNYXAiLCJlbWlzc2l2ZU1hcCIsImVtaXNzaW9uTWFwIiwiZW1pc3Npb24iLCJlbWlzc2l2ZSIsImdldEF0dHJpYnV0ZSIsImdldEluZGV4IiwiY29tcHV0ZVRhbmdlbnRzIiwidmVydGV4U2hhZGVyIiwicG93ZXIiLCJmcmFnbWVudFNoYWRlciIsImxpZ2h0cyIsInRyYW5zcGFyZW50Iiwic2lkZSIsImV4dGVuc2lvbnMiLCJkZXJpdmF0aXZlcyIsImRlZmluZXMiLCJVU0VfTUFQIiwiVVNFX1JPVUdITkVTU19NQVAiLCJVU0VfTUVUQUxORVNTX01BUCIsIlVTRV9BTFBIQV9NQVAiLCJVU0VfTk9STUFMX01BUCIsIlVTRV9FTUlTU0lPTl9NQVAiLCJzdXBlciIsInRoaXMiLCJuYW1lIiwidXNlckRhdGEiLCJjb2xvck1hdCIsImN1c3RvbURlcHRoTWF0ZXJpYWwiLCJjb21tb25Vbmlmb3JtcyIsInBvc2l0aW9uIiwiY29weSIsInJvdGF0aW9uIiwic2NhbGUiLCJlbnZNYXBTcmMiLCJlbnZNYXBVcGRhdGUiLCJlbnZNYXBSZW5kZXJUYXJnZXQiLCJmb3JtYXQiLCJnZW5lcmF0ZU1pcG1hcHMiLCJtYWdGaWx0ZXIiLCJtaW5GaWx0ZXIiLCJlbnZNYXBDYW1lcmEiLCJnZXRXb3JsZFBvc2l0aW9uIiwib25CZWZvcmVSZW5kZXIiLCJyZW5kZXJlciIsInNjZW5lIiwiY2FtZXJhIiwiZGlzcGF0Y2hFdmVudCIsInR5cGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImVudk1hcFJUIiwicG1yZW1HZW5lcmF0b3IiLCJjb21waWxlRXF1aXJlY3Rhbmd1bGFyU2hhZGVyIiwiZnJvbUN1YmVtYXAiLCJmcm9tRXF1aXJlY3Rhbmd1bGFyIiwidmlzaWJsZSIsInVwZGF0ZSIsInRleHR1cmUiLCJkZXB0aENhbWVyYSIsImRlcHRoTWF0IiwibmVhciIsImZhciIsIm9uRGlzcG9zZSIsImRpc3Bvc2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlRW52TWFwIiwiaXNQb3dlck1lc2giXSwic291cmNlUm9vdCI6IiJ9