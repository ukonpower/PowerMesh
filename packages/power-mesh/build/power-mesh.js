!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(require("three"),require("ore-three")):"function"==typeof define&&define.amd?define(["three","ore-three"],n):"object"==typeof exports?exports.PowerMesh=n(require("three"),require("ore-three")):t.PowerMesh=n(t.THREE,t.ORE)}(this,((t,n)=>(()=>{"use strict";var e={699:t=>{t.exports=n},381:n=>{n.exports=t}},i={};function o(t){var n=i[t];if(void 0!==n)return n.exports;var a=i[t]={exports:{}};return e[t](a,a.exports,o),a.exports}o.d=(t,n)=>{for(var e in n)o.o(n,e)&&!o.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:n[e]})},o.o=(t,n)=>Object.prototype.hasOwnProperty.call(t,n),o.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var a={};return(()=>{o.r(a),o.d(a,{PowerMesh:()=>r,PowerReflectionMesh:()=>s});var t=o(381),n=o(699);const e="#define GLSLIFY 1\nattribute vec4 tangent;\n\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewNormal;\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\nvarying vec3 vViewPos;\nvarying vec3 vWorldPos;\nvarying vec2 vHighPrecisionZW;\n\n/*-------------------------------\n\tShadowMap\n-------------------------------*/\n\n#include <shadowmap_pars_vertex>\n\nvoid main( void ) {\n\n\t/*-------------------------------\n\t\tPosition\n\t-------------------------------*/\n\n\tvec3 pos = position;\n\tvec4 worldPos = modelMatrix * vec4( pos, 1.0 );\n\tvec4 mvPosition = viewMatrix * worldPos;\n\t\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t/*-------------------------------\n\t\tNormal / Tangent\n\t-------------------------------*/\n\n\tvec3 transformedNormal = normalMatrix * normal;\n\tvec4 flipedTangent = tangent;\n\tflipedTangent.w *= -1.0;\n\n\t#ifdef FLIP_SIDED\n\t\ttransformedNormal *= -1.0;\n\t\tflipedTangent *= -1.0;\n\t#endif\n\t\n\tvec3 normal = normalize( transformedNormal );\n\tvec3 tangent = normalize( ( modelViewMatrix * vec4( flipedTangent.xyz, 0.0 ) ).xyz );\n\tvec3 biTangent = normalize( cross( normal, tangent ) * flipedTangent.w );\n\n\t/*-------------------------------\n\t\tShadow\n\t-------------------------------*/\n\t\n\tvec4 shadowWorldPos;\n\t\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\t\n\t\t\tshadowWorldPos = worldPos + vec4( vec4( transformedNormal, 0.0 ) * modelMatrix ) * directionalLightShadows[ i ].shadowNormalBias;\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPos;\n\t\t\t\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t\n\t#endif\n\n\t/*-------------------------------\n\t\tVarying\n\t-------------------------------*/\n\t\n\tvUv = uv;\n\tvNormal = normal;\n\tvTangent = tangent;\n\tvBitangent = biTangent;\n\tvViewPos = -mvPosition.xyz;\n\tvWorldPos = worldPos.xyz;\n\tvHighPrecisionZW = gl_Position.zw;\n\t\n}",i="#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec3 vTangent;\nvarying vec3 vBitangent;\n\n/*-------------------------------\n\tRequire\n-------------------------------*/\n\n#include <packing>\n\nvec2 packing16( float value ) { \n\n\tfloat v1 = value * 255.0;\n\tfloat r = floor(v1);\n\n\tfloat v2 = ( v1 - r ) * 255.0;\n\tfloat g = floor( v2 );\n\n\treturn vec2( r, g ) / 255.0;\n\n}\n\n/*-------------------------------\n\tRequiers\n-------------------------------*/\n\n#include <common>\n\nfloat random(vec2 p){\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/*-------------------------------\n\tMaterial Uniforms\n-------------------------------*/\n\nuniform float time;\n\n/*-------------------------------\n\tTextures\n-------------------------------*/\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#else\n\n\tuniform vec3 color;\n\n#endif\n\n#ifdef USE_NORMAL_MAP\n\n\tuniform sampler2D normalMap;\n\n#endif\n\n#ifdef USE_ROUGHNESS_MAP\n\n\tuniform sampler2D roughnessMap;\n\n#else\n\n\tuniform float roughness;\n\n#endif\n\n#ifdef USE_ALPHA_MAP\n\n\tuniform sampler2D alphaMap;\n\n#else\n\n\tuniform float opacity;\n\t\n#endif\n\n#ifdef USE_METALNESS_MAP\n\n\tuniform sampler2D metalnessMap;\n\n#else\n\n\tuniform float metalness;\n\n#endif\n#ifdef USE_EMISSION_MAP\n\n\tuniform sampler2D emissionMap;\n\n#else\n\n\tuniform vec3 emission;\n\n#endif\n\n#ifdef IS_REFLECTIONPLANE\n\n\tuniform sampler2D reflectionTex;\n\tuniform vec2 renderResolution;\n\tuniform vec2 mipMapResolution;\n\t\n#endif\n\n/*-------------------------------\n\tTypes\n-------------------------------*/\n\nstruct Geometry {\n\tvec3 pos;\n\tvec3 posWorld;\n\tvec3 viewDir;\n\tvec3 viewDirWorld;\n\tvec3 normal;\n\tvec3 normalWorld;\n};\n\nstruct Light {\n\tvec3 direction;\n\tvec3 color;\n};\n\nstruct Material {\n\tvec3 albedo;\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat metalness;\n\tfloat roughness;\n\tfloat opacity;\n};\n\n/*-------------------------------\n\tLights\n-------------------------------*/\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n#endif\n\n/*-------------------------------\n\tEnvMap\n-------------------------------*/\n\n#ifdef USE_ENV_MAP\n\n\tuniform sampler2D envMap;\n\tuniform float envMapIntensity;\n\tuniform float iblIntensity;\n\tuniform float maxLodLevel;\n\n\t#define ENVMAP_TYPE_CUBE_UV\n\t#include <cube_uv_reflection_fragment>\n\n#endif\n\n/*-------------------------------\n\tReflection\n-------------------------------*/\n\n#define REF_MIPMAP_LEVEL 8.0\n\n#ifdef IS_REFLECTIONPLANE\n\n\tvec2 getRefMipmapUV( vec2 uv, float level ) {\n\n\t\tvec2 ruv = uv;\n\n\t\tif( level > 0.0 ) {\n\n\t\t\truv.x *= 1.0 / ( 3.0 * ( pow( 2.0, level ) / 2.0 ) );\n\t\t\truv.y *= 1.0 / ( pow( 2.0, level ) );\n\t\t\truv.y += 1.0 / ( pow( 2.0, level ) );\n\t\t\truv.x += 1.0 / 1.5;\n\t\t\n\t\t} else {\n\n\t\t\truv.x /= 1.5;\n\t\t\t\n\t\t}\n\n\t\treturn ruv;\n\n\t}\n\t\n\tvec4 cubic(float v) {\n\t\tvec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n\t\tvec4 s = n * n * n;\n\t\tfloat x = s.x;\n\t\tfloat y = s.y - 4.0 * s.x;\n\t\tfloat z = s.z - 4.0 * s.y + 6.0 * s.x;\n\t\tfloat w = 6.0 - x - y - z;\n\t\treturn vec4(x, y, z, w);\n\t}\n\n\t// https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n\tvec4 textureBicubic(sampler2D t, vec2 texCoords, vec2 textureSize) {\n\t\tvec2 invTexSize = 1.0 / textureSize;\n\t\ttexCoords = texCoords * textureSize - 0.5;\n\t\tvec2 fxy = fract(texCoords);\n\t\ttexCoords -= fxy;\n\t\tvec4 xcubic = cubic(fxy.x);\n\t\tvec4 ycubic = cubic(fxy.y);\n\t\tvec4 c = texCoords.xxyy + vec2 (-0.5, 1.5).xyxy;\n\t\tvec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n\t\tvec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n\t\toffset *= invTexSize.xxyy;\n\t\tvec4 sample0 = texture2D(t, offset.xz);\n\t\tvec4 sample1 = texture2D(t, offset.yz);\n\t\tvec4 sample2 = texture2D(t, offset.xw);\n\t\tvec4 sample3 = texture2D(t, offset.yw);\n\t\tfloat sx = s.x / (s.x + s.y);\n\t\tfloat sy = s.z / (s.z + s.w);\n\t\treturn mix(\n\t\tmix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n\t}\n\n#endif\n\n/*-------------------------------\n\tShadow\n-------------------------------*/\n\n#ifdef DEPTH\n\n\tvarying vec2 vHighPrecisionZW;\n\tuniform float cameraNear;\n\tuniform float cameraFar;\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#define SHADOW_SAMPLE_COUNT 4\n\n\tvec2 poissonDisk[ SHADOW_SAMPLE_COUNT ];\n\n\tvoid initPoissonDisk( float seed ) {\n\n\t\tfloat r = 0.1;\n\t\tfloat rStep = (1.0 - r) / float( SHADOW_SAMPLE_COUNT );\n\n\t\tfloat ang = random( gl_FragCoord.xy * 0.01 + sin( time ) ) * PI2 * 1.0;\n\t\tfloat angStep = ( ( PI2 * 11.0 ) / float( SHADOW_SAMPLE_COUNT ) );\n\t\t\n\t\tfor( int i = 0; i < SHADOW_SAMPLE_COUNT; i++ ) {\n\n\t\t\tpoissonDisk[ i ] = vec2(\n\t\t\t\tsin( ang ),\n\t\t\t\tcos( ang )\n\t\t\t) * pow( r, 0.75 );\n\n\t\t\tr += rStep;\n\t\t\tang += angStep;\n\t\t}\n\t\t\n\t}\n\n\tvec2 compairShadowMapDepth( sampler2D shadowMap, vec2 shadowMapUV, float depth ) {\n\n\t\tif( shadowMapUV.x < 0.0 || shadowMapUV.x > 1.0 || shadowMapUV.y < 0.0 || shadowMapUV.y > 1.0 ) {\n\n\t\t\treturn vec2( 1.0, 0.0 );\n\n\t\t}\n\n\t\tfloat shadowMapDepth = unpackRGBAToDepth( texture2D( shadowMap, shadowMapUV ) );\n\n\t\tif( 0.0 >= shadowMapDepth || shadowMapDepth >= 1.0 ) {\n\n\t\t\treturn vec2( 1.0, 0.0 );\n\n\t\t}\n\t\t\n\t\tfloat shadow = depth <= shadowMapDepth ? 1.0 : 0.0;\n\n\t\treturn vec2( shadow, shadowMapDepth );\n\t\t\n\t}\n\n\tfloat shadowMapPCF( sampler2D shadowMap, vec4 shadowMapCoord, vec2 shadowSize ) {\n\n\t\tfloat shadow = 0.0;\n\t\t\n\t\tfor( int i = 0; i < SHADOW_SAMPLE_COUNT; i ++  ) {\n\t\t\t\n\t\t\tvec2 offset = poissonDisk[ i ] * shadowSize; \n\n\t\t\tshadow += compairShadowMapDepth( shadowMap, shadowMapCoord.xy + offset, shadowMapCoord.z ).x;\n\t\t\t\n\t\t}\n\n\t\tshadow /= float( SHADOW_SAMPLE_COUNT );\n\n\t\treturn shadow;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float bias, vec4 shadowMapCoord ) {\n\t\t\n\t\tshadowMapCoord.xyz /= shadowMapCoord.w;\n\t\tshadowMapCoord.z += bias - 0.0001;\n\n\t\tinitPoissonDisk(time);\n\n\t\tvec2 shadowSize = 1.0 / shadowMapSize;\n\n\t\treturn shadowMapPCF( shadowMap, shadowMapCoord, shadowSize );\n\n\t}\n\n#endif\n\n/*-------------------------------\n\tRE\n-------------------------------*/\n\nvarying vec3 vNormal;\nvarying vec3 vViewNormal;\nvarying vec3 vViewPos;\nvarying vec3 vWorldPos;\n\nfloat ggx( float dNH, float roughness ) {\n\t\n\tfloat a2 = roughness * roughness;\n\ta2 = a2 * a2;\n\tfloat dNH2 = dNH * dNH;\n\n\tif( dNH2 <= 0.0 ) return 0.0;\n\n\treturn a2 / ( PI * pow( dNH2 * ( a2 - 1.0 ) + 1.0, 2.0) );\n\n}\n\nvec3 lambert( vec3 diffuseColor ) {\n\n\treturn diffuseColor / PI;\n\n}\n\nfloat gSchlick( float d, float k ) {\n\n\tif( d == 0.0 ) return 0.0;\n\n\treturn d / ( d * ( 1.0 - k ) + k );\n\t\n}\n\nfloat gSmith( float dNV, float dNL, float roughness ) {\n\n\tfloat k = clamp( roughness * sqrt( 2.0 / PI ), 0.0, 1.0 );\n\n\treturn gSchlick( dNV, k ) * gSchlick( dNL, k );\n\t\n}\n\nfloat fresnel( float d ) {\n\t\n\tfloat f0 = 0.04;\n\n\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - d, 5.0 );\n\n}\n\nvec3 RE( Geometry geo, Material mat, Light light) {\n\n\tvec3 lightDir = normalize( light.direction );\n\tvec3 halfVec = normalize( geo.viewDir + lightDir );\n\n\tfloat dLH = clamp( dot( lightDir, halfVec ), 0.0, 1.0 );\n\tfloat dNH = clamp( dot( geo.normal, halfVec ), 0.0, 1.0 );\n\tfloat dNV = clamp( dot( geo.normal, geo.viewDir ), 0.0, 1.0 );\n\tfloat dNL = clamp( dot( geo.normal, lightDir), 0.0, 1.0 );\n\n\tvec3 irradiance = light.color * dNL;\n\n\t// diffuse\n\tvec3 diffuse = lambert( mat.diffuseColor ) * irradiance;\n\n\t// specular\n\tfloat D = ggx( dNH, mat.roughness );\n\tfloat G = gSmith( dNV, dNL, mat.roughness );\n\tfloat F = fresnel( dLH );\n\t\n\tvec3 specular = (( D * G * F ) / ( 4.0 * dNL * dNV + 0.0001 ) * mat.specularColor ) * irradiance; \n\n\tvec3 c = vec3( 0.0 );\n\tc += diffuse * ( 1.0 - F ) + specular;\n\n\treturn c;\n\n}\n\n/*-------------------------------\n\tMain\n-------------------------------*/\n\nvoid main( void ) {\n\n\t/*-------------------------------\n\t\tMaterial\n\t-------------------------------*/\n\n\tMaterial mat;\n\n\t#ifdef USE_MAP\n\n\t\tvec4 color = LinearTosRGB( texture2D( map, vUv ) );\n\t\tmat.albedo = color.xyz;\n\t\tmat.opacity = color.w;\n\n\t#else\n\n\t\tmat.albedo = color.xyz;\n\t\tmat.opacity = 1.0;\n\t\n\t#endif\n\n\t#ifdef USE_ROUGHNESS_MAP\n\n\t\tmat.roughness = texture2D( roughnessMap, vUv ).y;\n\n\t#else\n\n\t\tmat.roughness = roughness;\n\t\n\t#endif\n\n\t#ifdef USE_METALNESS_MAP\n\n\t\tmat.metalness = texture2D( metalnessMap, vUv ).z;\n\n\t#else\n\n\t\tmat.metalness = metalness;\n\t\n\t#endif\n\n\t#ifdef USE_ALPHA_MAP\n\n\t\tmat.opacity = texture2D( alphaMap, vUv ).x;\n\n\t#else\n\n\t\tmat.opacity *= opacity;\n\n\t#endif\n\t\n\t// if( mat.opacity < 0.5 ) discard;\n\n\tmat.diffuseColor = mix( mat.albedo, vec3( 0.0, 0.0, 0.0 ), mat.metalness );\n\tmat.specularColor = mix( vec3( 1.0, 1.0, 1.0 ), mat.albedo, mat.metalness );\n\n\t// output\n\tvec3 outColor = vec3( 0.0 );\n\tfloat outOpacity = mat.opacity;\n\n\t/*-------------------------------\n\t\tDepth\n\t-------------------------------*/\n\n\t#ifdef DEPTH\n\n\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW.x / vHighPrecisionZW.y + 0.5;\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t\treturn;\n\t\n\t#endif\n\n\t/*-------------------------------\n\t\tGeometry\n\t-------------------------------*/\n\n\tfloat faceDirection = gl_FrontFacing ? 1.0 : -1.0;\n\n\tGeometry geo;\n\tgeo.pos = -vViewPos;\n\tgeo.posWorld = vWorldPos;\n\tgeo.viewDir = normalize( vViewPos );\n\tgeo.viewDirWorld = normalize( geo.posWorld - cameraPosition );\n\tgeo.normal = normalize( vNormal ) * faceDirection;\n\n\t#ifdef USE_NORMAL_MAP\n\t\t\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent *= faceDirection;\n\t\t\tbitangent *= faceDirection;\n\t\t\n\t\t#endif\n\t\t\n\t\tmat3 vTBN = mat3( tangent, bitangent, geo.normal );\n\t\t\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz;\n\t\tmapN = mapN * 2.0 - 1.0;\n\t\tgeo.normal = normalize( vTBN * mapN );\n\n\t#endif\n\t\n\tgeo.normalWorld = normalize( ( vec4( geo.normal, 0.0 ) * viewMatrix ).xyz );\n\n\t/*-------------------------------\n\t\tLighting\n\t-------------------------------*/\n\t\n\tLight light;\n\n\t#if NUM_DIR_LIGHTS > 0\n\n\t\tfloat shadow;\n\n\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\t\tlight.direction = directionalLights[ i ].direction;\n\t\t\t\tlight.color = directionalLights[ i ].color;\n\t\t\t\tshadow = 1.0;\n\n\t\t\t\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\t\t\t\tshadow = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ].shadowMapSize, directionalLightShadows[ i ].shadowBias, vDirectionalShadowCoord[ i ] );\n\n\t\t\t\t#endif\n\n\t\t\t\toutColor += RE( geo, mat, light ) * shadow;\n\t\t\t\t\n\t\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHTS > 0\n\n\t\tPointLight pLight;\n\t\tvec3 v;\n\t\tfloat d;\n\t\tfloat attenuation;\n\t\t#pragma unroll_loop_start\n\n\t\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\t\tpLight = pointLights[ i ];\n\n\t\t\t\tv = pLight.position - geo.pos;\n\t\t\t\td = length( v );\n\t\t\t\tlight.direction = normalize( v );\n\t\t\n\t\t\t\tlight.color = pLight.color;\n\n\t\t\t\tif( pLight.distance > 0.0 && pLight.decay > 0.0 ) {\n\n\t\t\t\t\tattenuation = pow( clamp( -d / pLight.distance + 1.0, 0.0, 1.0 ), pLight.decay );\n\t\t\t\t\tlight.color *= attenuation;\n\n\t\t\t\t}\n\n\t\t\t\toutColor += RE( geo, mat, light );\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if defined( USE_ENV_MAP ) || defined( IS_REFLECTIONPLANE )\n\n\t\tfloat dNV = clamp( dot( geo.normal, geo.viewDir ), 0.0, 1.0 );\n\t\tfloat EF = fresnel( dNV );\n\n\t#endif\n\n\t/*-------------------------------\n\t\tEnvironment Lighting\n\t-------------------------------*/\n\n\t#ifdef USE_ENV_MAP\n\n\t\tvec3 refDir = reflect( geo.viewDirWorld, geo.normalWorld );\n\t\trefDir.x *= -1.0;\n\t\n\t\tvec4 envMapColor = textureCubeUV( envMap, geo.normalWorld, 1.0 ) * iblIntensity * envMapIntensity;\n\t\toutColor += mat.diffuseColor * envMapColor.xyz * ( 1.0 - mat.metalness );\n\n\t#endif\n\n\t/*-------------------------------\n\t\tReflection\n\t-------------------------------*/\n\t\n\t#ifdef IS_REFLECTIONPLANE\n\t\n\t\tvec2 refUV = gl_FragCoord.xy / renderResolution;\n\n\t\trefUV.x += geo.normal.x * 0.5;\n\n\t\tfloat l = (mat.roughness ) * 1.6 * REF_MIPMAP_LEVEL;\n\n\t\tfloat offset1 = floor( l );\n\t\tfloat offset2 = offset1 + 1.0;\n\t\tfloat blend = fract( l );\n\t\t\n\t\tvec2 ruv1 = getRefMipmapUV( refUV, offset1 );\n\t\tvec2 ruv2 = getRefMipmapUV( refUV, offset2 );\n\n\t\tvec3 ref1 = textureBicubic( reflectionTex, ruv1, mipMapResolution ).xyz;\n\t\tvec3 ref2 = textureBicubic( reflectionTex, ruv2, mipMapResolution ).xyz;\n\n\t\tvec3 ref = mat.specularColor * mix( ref1, ref2, blend );\n\n\t\toutColor = mix(\n\t\t\toutColor + ref * mat.metalness,\n\t\t\tref,\n\t\t\tEF\n\t\t);\n\n\t#elif defined( USE_ENV_MAP )\n\t\n\t\tvec3 env = mat.specularColor * textureCubeUV( envMap, refDir, mat.roughness ).xyz * envMapIntensity;\n\t\n\t\toutColor = mix(\n\t\t\toutColor + env * mat.metalness,\n\t\t\tenv,\n\t\t\tEF\n\t\t);\n\t\n\t#endif\n\n\t/*-------------------------------\n\t\tEmission\n\t-------------------------------*/\n\n\t#ifdef USE_EMISSION_MAP\n\n\t\toutColor += LinearTosRGB( texture2D( emissionMap, vUv ) ).xyz;\n\t\n\t#else\n\n\t\toutColor += emission;\n\n\t#endif\n\n\tgl_FragColor = vec4( outColor, outOpacity );\n\n}";class r extends t.SkinnedMesh{constructor(o,a,r){a=a||{};let s,l=n.UniformsLib.mergeUniforms(a.uniforms||{},{envMap:{value:null},envMapIntensity:{value:null},iblIntensity:{value:null},maxLodLevel:{value:0},shadowLightModelViewMatrix:{value:new t.Matrix4},shadowLightProjectionMatrix:{value:new t.Matrix4},shadowLightDirection:{value:new t.Vector3},shadowLightCameraClip:{value:new t.Vector2},shadowMap:{value:null},shadowMapSize:{value:new t.Vector2},shadowMapResolution:{value:new t.Vector2},shadowLightSize:{value:1},cameraNear:{value:.01},cameraFar:{value:1e3},color:{value:new t.Color(1,1,1)},metalness:{value:0},roughness:{value:.5},opacity:{value:1},emission:{value:new t.Color(0,0,0)}});if(l=n.UniformsLib.mergeUniforms(l,t.UniformsUtils.clone(t.UniformsLib.lights)),"isBufferGeometry"in o)s=o;else if("isMesh"in o){s=o.geometry;let t=o.material;t.isMeshStandardMaterial&&(t.map?l.map={value:t.map}:t.color&&l.color.value.copy(t.color),t.roughnessMap?l.roughnessMap={value:t.roughnessMap}:l.roughness.value=t.roughness,t.alphaMap?l.alphaMap={value:t.alphaMap}:l.opacity.value=t.opacity,t.metalnessMap?l.metalnessMap={value:t.metalnessMap}:l.metalness.value=t.metalness,t.normalMap&&(l.normalMap={value:t.normalMap}),t.emissiveMap?l.emissionMap={value:t.emissiveMap}:l.emission.value.copy(t.emissive))}else s=new t.BufferGeometry;s.getAttribute("tangent")||s.getIndex()&&s.getAttribute("position")&&s.getAttribute("normal")&&s.getAttribute("uv")&&s.computeTangents(),a.uniforms=l;let c=new t.ShaderMaterial(Object.assign({vertexShader:e,fragmentShader:i,lights:!0,transparent:!0,side:t.DoubleSide,extensions:{derivatives:!0},defines:{}},a));if(l.map&&(c.defines.USE_MAP=""),l.roughnessMap&&(c.defines.USE_ROUGHNESS_MAP=""),l.metalnessMap&&(c.defines.USE_METALNESS_MAP=""),l.alphaMap&&(c.defines.USE_ALPHA_MAP=""),l.normalMap&&(c.defines.USE_NORMAL_MAP=""),l.emissionMap&&(c.defines.USE_EMISSION_MAP=""),super(s,c),this.name=o.name,this.userData.colorMat=this.material,this.customDepthMaterial=new t.ShaderMaterial(Object.assign(Object.assign({vertexShader:e,fragmentShader:i,side:t.DoubleSide,lights:!0,extensions:{derivatives:!0}},a),{defines:Object.assign(Object.assign({},c.defines),{DEPTH:""})})),this.commonUniforms=l,"isMesh"in o&&r){o.geometry.dispose(),o.children.slice().forEach((t=>{this.add(t)})),this.position.copy(o.position),this.rotation.copy(o.rotation),this.scale.copy(o.scale);let t=o.parent;t&&(t.add(this),t.remove(o))}"isMesh"in o&&(o.animations.forEach((t=>{this.animations.push(t)})),"isSkinnedMesh"in o?o.skeleton&&(this.skeleton=o.skeleton):this.skeleton=new t.Skeleton([])),this.envMapSrc=null,this.envMapUpdate=!1,this.envMapResolution=256,this.envMapRenderTarget=new t.WebGLCubeRenderTarget(this.envMapResolution,{format:t.RGBAFormat,generateMipmaps:!0,magFilter:t.LinearFilter,minFilter:t.LinearFilter}),this.envMapCamera=new t.CubeCamera(.001,1e3,this.envMapRenderTarget),this.getWorldPosition(this.envMapCamera.position),this.onBeforeRender=(t,n,e)=>{this.dispatchEvent({type:"beforeRender",renderer:t,scene:n,camera:e})},this.addEventListener("beforeRender",(n=>{let e=n.renderer,i=n.scene,o=n.camera;if(this.envMapUpdate){let n=null,o=new t.PMREMGenerator(e);o.compileEquirectangularShader(),this.envMapSrc?n="isCubeTexture"in this.envMapSrc?o.fromCubemap(this.envMapSrc):o.fromEquirectangular(this.envMapSrc):(this.visible=!1,this.envMapCamera.update(e,i),n=o.fromCubemap(this.envMapRenderTarget.texture),this.visible=!0);let a=n.height;const r=Math.round(Math.log2(a))-2,s=1/a,l=1/(3*Math.max(Math.pow(2,r),112));c.defines.USE_ENV_MAP="",c.defines.CUBEUV_MAX_MIP=r+".0",c.defines.CUBEUV_TEXEL_WIDTH=l+"",c.defines.CUBEUV_TEXEL_HEIGHT=s+"",this.commonUniforms.envMap.value=n.texture,this.envMapUpdate=!1}o.userData.depthCamera&&(this.material=this.userData.depthMat,this.commonUniforms.cameraNear.value=o.near,this.commonUniforms.cameraFar.value=o.far,this.material||(this.visible=!1))}));const d=()=>{this.envMapRenderTarget.dispose(),this.geometry.dispose(),this.material.dispose(),this.removeEventListener("dispose",d)};this.addEventListener("dispose",d)}updateEnvMap(t=null){this.envMapSrc=t,this.envMapUpdate=!0,null==this.commonUniforms.envMapIntensity.value&&(this.commonUniforms.envMapIntensity.value=1),null==this.commonUniforms.iblIntensity.value&&(this.commonUniforms.iblIntensity.value=1)}set envMapIntensity(t){this.commonUniforms.envMapIntensity.value=t}set iblIntensity(t){this.commonUniforms.iblIntensity.value=t}dispose(){this.dispatchEvent({type:"dispsoe"})}get isPowerMesh(){return!0}}class s extends r{constructor(e,i,o){(i=i||{}).uniforms=n.UniformsLib.mergeUniforms(i.uniforms||{},{reflectionTex:{value:null},renderResolution:{value:new t.Vector2(1,1)},textureMatrix:{value:new t.Matrix4},mipMapResolution:{value:new t.Vector2(1,1)}}),i.defines={IS_REFLECTIONPLANE:""},super(e,i,o),this.reflectorPlane=new t.Plane,this.normal=new t.Vector3,this.reflectorWorldPosition=new t.Vector3,this.cameraWorldPosition=new t.Vector3,this.rotationMatrix=new t.Matrix4,this.lookAtPosition=new t.Vector3(0,0,-1),this.clipPlane=new t.Vector4,this.textureMatrix=this.commonUniforms.textureMatrix.value,this.clipBias=.1,this.view=new t.Vector3,this.target=new t.Vector3,this.q=new t.Vector4,this.virtualCamera=new t.PerspectiveCamera,this.mipmapPP=null,this.mipmapGeo=new t.BufferGeometry;let a=[],r=[],s=[],l=new t.Vector2(0,0),c=2;a.push(l.x,l.y,0),a.push(l.x+c,l.y,0),a.push(l.x+c,l.y-c,0),a.push(l.x,l.y-c,0),r.push(1,1),r.push(0,1),r.push(0,0),r.push(1,0),s.push(0,2,1,0,3,2),l.set(c,0);for(let t=0;t<7;t++){c*=.5,a.push(l.x,l.y,0),a.push(l.x+c,l.y,0),a.push(l.x+c,l.y-c,0),a.push(l.x,l.y-c,0),r.push(1,1),r.push(0,1),r.push(0,0),r.push(1,0);let n=4*(t+0);s.push(n+0,n+2,n+1,n+0,n+3,n+2),l.y=l.y-c}let d=new t.BufferAttribute(new Float32Array(a),3),m=new t.BufferAttribute(new Float32Array(r),2),f=new t.BufferAttribute(new Uint16Array(s),1);d.applyMatrix4((new t.Matrix4).makeScale(1/1.5,1,1)),d.applyMatrix4((new t.Matrix4).makeTranslation(-1,1,0)),this.mipmapGeo.setAttribute("position",d),this.mipmapGeo.setAttribute("uv",m),this.mipmapGeo.setIndex(f),this.renderTargets={ref:new t.WebGLRenderTarget(1,1),mipmap:new t.WebGLRenderTarget(1,1)},this.addEventListener("beforeRender",(e=>{let i=e.renderer,o=e.scene,a=e.camera;if(this.reflectorWorldPosition.setFromMatrixPosition(this.matrixWorld),this.cameraWorldPosition.setFromMatrixPosition(a.matrixWorld),this.rotationMatrix.extractRotation(this.matrixWorld),this.normal.set(0,1,0),this.normal.applyMatrix4(this.rotationMatrix),this.view.subVectors(this.reflectorWorldPosition,this.cameraWorldPosition),this.view.dot(this.normal)>0)return;this.view.reflect(this.normal).negate(),this.view.add(this.reflectorWorldPosition),this.rotationMatrix.extractRotation(a.matrixWorld),this.lookAtPosition.set(0,0,-1),this.lookAtPosition.applyMatrix4(this.rotationMatrix),this.lookAtPosition.add(this.cameraWorldPosition),this.target.subVectors(this.reflectorWorldPosition,this.lookAtPosition),this.target.reflect(this.normal).negate(),this.target.add(this.reflectorWorldPosition),this.virtualCamera.position.copy(this.view),this.virtualCamera.up.set(0,1,0),this.virtualCamera.up.applyMatrix4(this.rotationMatrix),this.virtualCamera.up.reflect(this.normal),this.virtualCamera.lookAt(this.target),a.far&&(this.virtualCamera.far=a.far),this.virtualCamera.updateMatrixWorld(),this.virtualCamera.projectionMatrix.copy(a.projectionMatrix),this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.virtualCamera.projectionMatrix),this.textureMatrix.multiply(this.virtualCamera.matrixWorldInverse),this.textureMatrix.multiply(this.matrixWorld),this.reflectorPlane.setFromNormalAndCoplanarPoint(this.normal,this.reflectorWorldPosition),this.reflectorPlane.applyMatrix4(this.virtualCamera.matrixWorldInverse),this.clipPlane.set(this.reflectorPlane.normal.x,this.reflectorPlane.normal.y,this.reflectorPlane.normal.z,this.reflectorPlane.constant);var r=this.virtualCamera.projectionMatrix;this.q.x=(Math.sign(this.clipPlane.x)+r.elements[8])/r.elements[0],this.q.y=(Math.sign(this.clipPlane.y)+r.elements[9])/r.elements[5],this.q.z=-1,this.q.w=(1+r.elements[10])/r.elements[14],this.clipPlane.multiplyScalar(2/this.clipPlane.dot(this.q)),r.elements[2]=this.clipPlane.x,r.elements[6]=this.clipPlane.y,r.elements[10]=this.clipPlane.z+1-this.clipBias,r.elements[14]=this.clipPlane.w;let s=i.getRenderTarget();i.setRenderTarget(this.renderTargets.ref),this.visible=!1,i.clear(),i.render(o,this.virtualCamera),i.clearDepth(),i.setRenderTarget(s),this.visible=!0,null==this.mipmapPP&&(this.mipmapPP=new n.PostProcessing(i,{fragmentShader:"#define GLSLIFY 1\nuniform sampler2D tex;\nvarying vec2 vUv;\n\nfloat clip( vec2 uv ) {\n\tvec2 c = step( abs(uv - 0.5), vec2( 0.5 ) );\n\treturn c.x * c.y;\n}\n\nvoid main( void ) {\n\n\tvec4 col = texture2D( tex, vUv );\n\tgl_FragColor = col;\n\n}",side:t.DoubleSide},this.mipmapGeo)),this.mipmapPP.render({tex:this.renderTargets.ref.texture},this.renderTargets.mipmap),this.commonUniforms.reflectionTex.value=this.renderTargets.mipmap.texture;let l=i.getRenderTarget();l?this.commonUniforms.renderResolution.value.set(l.width,l.height):(i.getSize(this.commonUniforms.renderResolution.value),this.commonUniforms.renderResolution.value.multiplyScalar(i.getPixelRatio()))})),this.resize()}resize(n=new t.Vector2){this.renderTargets.ref.setSize(n.x,n.y);let e=new t.Vector2(1.5*n.x,n.y);this.renderTargets.mipmap.setSize(e.x,e.y),this.commonUniforms.mipMapResolution.value.copy(e)}}})(),a})()));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZTZELGlCQUFpQjdILE9BQ3ZEekIsS0FBS3lGLGVBQWU2RCxpQkFBaUI3SCxNQUFNeUwsZUFBZ0I5RixFQUFTeUcscUJBTXRFN04sS0FBSzhOLFNBSUNBLE9BQVFDLEVBQXNCLElBQUksV0FFeEMvTixLQUFLNEwsY0FBY0MsSUFBSW1DLFFBQVNELEVBQUtsRCxFQUFHa0QsRUFBS2pELEdBRTdDLElBQUltRCxFQUFhLElBQUksVUFBd0IsSUFBVEYsRUFBS2xELEVBQVNrRCxFQUFLakQsR0FDdkQ5SyxLQUFLNEwsY0FBY0UsT0FBT2tDLFFBQVNDLEVBQVdwRCxFQUFHb0QsRUFBV25ELEdBQzVEOUssS0FBS3lGLGVBQWUrRCxpQkFBaUIvSCxNQUFNaUMsS0FBTXVLLE0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Qb3dlck1lc2gvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1Bvd2VyTWVzaC9leHRlcm5hbCB1bWQge1wiY29tbW9uanNcIjpcIm9yZS10aHJlZVwiLFwiY29tbW9uanMyXCI6XCJvcmUtdGhyZWVcIixcImFtZFwiOlwib3JlLXRocmVlXCIsXCJyb290XCI6XCJPUkVcIn0iLCJ3ZWJwYWNrOi8vUG93ZXJNZXNoL2V4dGVybmFsIHVtZCB7XCJjb21tb25qc1wiOlwidGhyZWVcIixcImNvbW1vbmpzMlwiOlwidGhyZWVcIixcImFtZFwiOlwidGhyZWVcIixcInJvb3RcIjpcIlRIUkVFXCJ9Iiwid2VicGFjazovL1Bvd2VyTWVzaC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9Qb3dlck1lc2gvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL1Bvd2VyTWVzaC93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL1Bvd2VyTWVzaC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL1Bvd2VyTWVzaC8uL3NyYy9Qb3dlck1lc2gvc2hhZGVycy9wb3dlci52cyIsIndlYnBhY2s6Ly9Qb3dlck1lc2gvLi9zcmMvUG93ZXJNZXNoL3NoYWRlcnMvcG93ZXIuZnMiLCJ3ZWJwYWNrOi8vUG93ZXJNZXNoLy4vc3JjL1Bvd2VyTWVzaC9pbmRleC50cyIsIndlYnBhY2s6Ly9Qb3dlck1lc2gvLi9zcmMvUG93ZXJSZWZsZWN0aW9uTWVzaC9pbmRleC50cyIsIndlYnBhY2s6Ly9Qb3dlck1lc2gvLi9zcmMvUG93ZXJSZWZsZWN0aW9uTWVzaC9zaGFkZXJzL21pcG1hcC5mcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJ0aHJlZVwiKSwgcmVxdWlyZShcIm9yZS10aHJlZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJ0aHJlZVwiLCBcIm9yZS10aHJlZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQb3dlck1lc2hcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJ0aHJlZVwiKSwgcmVxdWlyZShcIm9yZS10aHJlZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiUG93ZXJNZXNoXCJdID0gZmFjdG9yeShyb290W1wiVEhSRUVcIl0sIHJvb3RbXCJPUkVcIl0pO1xufSkodGhpcywgKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM4MV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX182OTlfXykgPT4ge1xucmV0dXJuICIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNjk5X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zODFfXzsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBHTFNMSUZZIDFcXG5hdHRyaWJ1dGUgdmVjNCB0YW5nZW50O1xcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxudmFyeWluZyB2ZWMzIHZWaWV3Tm9ybWFsO1xcbnZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcXG52YXJ5aW5nIHZlYzMgdkJpdGFuZ2VudDtcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3M7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvcztcXG52YXJ5aW5nIHZlYzIgdkhpZ2hQcmVjaXNpb25aVztcXG5cXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRTaGFkb3dNYXBcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcblxcbnZvaWQgbWFpbiggdm9pZCApIHtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHRQb3NpdGlvblxcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdHZlYzMgcG9zID0gcG9zaXRpb247XFxuXFx0dmVjNCB3b3JsZFBvcyA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zLCAxLjAgKTtcXG5cXHR2ZWM0IG12UG9zaXRpb24gPSB2aWV3TWF0cml4ICogd29ybGRQb3M7XFxuXFx0XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHROb3JtYWwgLyBUYW5nZW50XFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuXFx0dmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG5vcm1hbDtcXG5cXHR2ZWM0IGZsaXBlZFRhbmdlbnQgPSB0YW5nZW50O1xcblxcdGZsaXBlZFRhbmdlbnQudyAqPSAtMS4wO1xcblxcblxcdCNpZmRlZiBGTElQX1NJREVEXFxuXFx0XFx0dHJhbnNmb3JtZWROb3JtYWwgKj0gLTEuMDtcXG5cXHRcXHRmbGlwZWRUYW5nZW50ICo9IC0xLjA7XFxuXFx0I2VuZGlmXFxuXFx0XFxuXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuXFx0dmVjMyB0YW5nZW50ID0gbm9ybWFsaXplKCAoIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIGZsaXBlZFRhbmdlbnQueHl6LCAwLjAgKSApLnh5eiApO1xcblxcdHZlYzMgYmlUYW5nZW50ID0gbm9ybWFsaXplKCBjcm9zcyggbm9ybWFsLCB0YW5nZW50ICkgKiBmbGlwZWRUYW5nZW50LncgKTtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHRTaGFkb3dcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXHRcXG5cXHR2ZWM0IHNoYWRvd1dvcmxkUG9zO1xcblxcdFxcblxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcdFxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUX1NIQURPV1M7IGkgKysgKSB7XFxuXFx0XFx0XFx0XFxuXFx0XFx0XFx0c2hhZG93V29ybGRQb3MgPSB3b3JsZFBvcyArIHZlYzQoIHZlYzQoIHRyYW5zZm9ybWVkTm9ybWFsLCAwLjAgKSAqIG1vZGVsTWF0cml4ICkgKiBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd05vcm1hbEJpYXM7XFxuXFx0XFx0XFx0dkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIGkgXSA9IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBpIF0gKiBzaGFkb3dXb3JsZFBvcztcXG5cXHRcXHRcXHRcXG5cXHRcXHR9XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXHRcXHRcXG5cXHQjZW5kaWZcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHRWYXJ5aW5nXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFx0XFxuXFx0dlV2ID0gdXY7XFxuXFx0dk5vcm1hbCA9IG5vcm1hbDtcXG5cXHR2VGFuZ2VudCA9IHRhbmdlbnQ7XFxuXFx0dkJpdGFuZ2VudCA9IGJpVGFuZ2VudDtcXG5cXHR2Vmlld1BvcyA9IC1tdlBvc2l0aW9uLnh5ejtcXG5cXHR2V29ybGRQb3MgPSB3b3JsZFBvcy54eXo7XFxuXFx0dkhpZ2hQcmVjaXNpb25aVyA9IGdsX1Bvc2l0aW9uLnp3O1xcblxcdFxcbn1cIjsiLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgR0xTTElGWSAxXFxudmFyeWluZyB2ZWMyIHZVdjtcXG52YXJ5aW5nIHZlYzMgdlRhbmdlbnQ7XFxudmFyeWluZyB2ZWMzIHZCaXRhbmdlbnQ7XFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0UmVxdWlyZVxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiNpbmNsdWRlIDxwYWNraW5nPlxcblxcbnZlYzIgcGFja2luZzE2KCBmbG9hdCB2YWx1ZSApIHsgXFxuXFxuXFx0ZmxvYXQgdjEgPSB2YWx1ZSAqIDI1NS4wO1xcblxcdGZsb2F0IHIgPSBmbG9vcih2MSk7XFxuXFxuXFx0ZmxvYXQgdjIgPSAoIHYxIC0gciApICogMjU1LjA7XFxuXFx0ZmxvYXQgZyA9IGZsb29yKCB2MiApO1xcblxcblxcdHJldHVybiB2ZWMyKCByLCBnICkgLyAyNTUuMDtcXG5cXG59XFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0UmVxdWllcnNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4jaW5jbHVkZSA8Y29tbW9uPlxcblxcbmZsb2F0IHJhbmRvbSh2ZWMyIHApe1xcblxcdHJldHVybiBmcmFjdChzaW4oZG90KHAueHkgLHZlYzIoMTIuOTg5OCw3OC4yMzMpKSkgKiA0Mzc1OC41NDUzKTtcXG59XFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0TWF0ZXJpYWwgVW5pZm9ybXNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG51bmlmb3JtIGZsb2F0IHRpbWU7XFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0VGV4dHVyZXNcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4jaWZkZWYgVVNFX01BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZWxzZVxcblxcblxcdHVuaWZvcm0gdmVjMyBjb2xvcjtcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX05PUk1BTF9NQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9ST1VHSE5FU1NfTUFQXFxuXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwO1xcblxcbiNlbHNlXFxuXFxuXFx0dW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7XFxuXFxuI2VuZGlmXFxuXFxuI2lmZGVmIFVTRV9BTFBIQV9NQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG5cXG4jZWxzZVxcblxcblxcdHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG5cXHRcXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX01FVEFMTkVTU19NQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7XFxuXFxuI2Vsc2VcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IG1ldGFsbmVzcztcXG5cXG4jZW5kaWZcXG4jaWZkZWYgVVNFX0VNSVNTSU9OX01BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaW9uTWFwO1xcblxcbiNlbHNlXFxuXFxuXFx0dW5pZm9ybSB2ZWMzIGVtaXNzaW9uO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBJU19SRUZMRUNUSU9OUExBTkVcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCByZWZsZWN0aW9uVGV4O1xcblxcdHVuaWZvcm0gdmVjMiByZW5kZXJSZXNvbHV0aW9uO1xcblxcdHVuaWZvcm0gdmVjMiBtaXBNYXBSZXNvbHV0aW9uO1xcblxcdFxcbiNlbmRpZlxcblxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdFR5cGVzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuc3RydWN0IEdlb21ldHJ5IHtcXG5cXHR2ZWMzIHBvcztcXG5cXHR2ZWMzIHBvc1dvcmxkO1xcblxcdHZlYzMgdmlld0RpcjtcXG5cXHR2ZWMzIHZpZXdEaXJXb3JsZDtcXG5cXHR2ZWMzIG5vcm1hbDtcXG5cXHR2ZWMzIG5vcm1hbFdvcmxkO1xcbn07XFxuXFxuc3RydWN0IExpZ2h0IHtcXG5cXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHR2ZWMzIGNvbG9yO1xcbn07XFxuXFxuc3RydWN0IE1hdGVyaWFsIHtcXG5cXHR2ZWMzIGFsYmVkbztcXG5cXHR2ZWMzIGRpZmZ1c2VDb2xvcjtcXG5cXHR2ZWMzIHNwZWN1bGFyQ29sb3I7XFxuXFx0ZmxvYXQgbWV0YWxuZXNzO1xcblxcdGZsb2F0IHJvdWdobmVzcztcXG5cXHRmbG9hdCBvcGFjaXR5O1xcbn07XFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0TGlnaHRzXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcblxcdHN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0IHtcXG5cXHRcXHR2ZWMzIGRpcmVjdGlvbjtcXG5cXHRcXHR2ZWMzIGNvbG9yO1xcblxcdH07XFxuXFxuXFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHRzWyBOVU1fRElSX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcblxcdHN0cnVjdCBQb2ludExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0fTtcXG5cXG5cXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRFbnZNYXBcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4jaWZkZWYgVVNFX0VOVl9NQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0dW5pZm9ybSBmbG9hdCBpYmxJbnRlbnNpdHk7XFxuXFx0dW5pZm9ybSBmbG9hdCBtYXhMb2RMZXZlbDtcXG5cXG5cXHQjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcXG5cXHQjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcblxcbiNlbmRpZlxcblxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdFJlZmxlY3Rpb25cXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG4jZGVmaW5lIFJFRl9NSVBNQVBfTEVWRUwgOC4wXFxuXFxuI2lmZGVmIElTX1JFRkxFQ1RJT05QTEFORVxcblxcblxcdHZlYzIgZ2V0UmVmTWlwbWFwVVYoIHZlYzIgdXYsIGZsb2F0IGxldmVsICkge1xcblxcblxcdFxcdHZlYzIgcnV2ID0gdXY7XFxuXFxuXFx0XFx0aWYoIGxldmVsID4gMC4wICkge1xcblxcblxcdFxcdFxcdHJ1di54ICo9IDEuMCAvICggMy4wICogKCBwb3coIDIuMCwgbGV2ZWwgKSAvIDIuMCApICk7XFxuXFx0XFx0XFx0cnV2LnkgKj0gMS4wIC8gKCBwb3coIDIuMCwgbGV2ZWwgKSApO1xcblxcdFxcdFxcdHJ1di55ICs9IDEuMCAvICggcG93KCAyLjAsIGxldmVsICkgKTtcXG5cXHRcXHRcXHRydXYueCArPSAxLjAgLyAxLjU7XFxuXFx0XFx0XFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRydXYueCAvPSAxLjU7XFxuXFx0XFx0XFx0XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBydXY7XFxuXFxuXFx0fVxcblxcdFxcblxcdHZlYzQgY3ViaWMoZmxvYXQgdikge1xcblxcdFxcdHZlYzQgbiA9IHZlYzQoMS4wLCAyLjAsIDMuMCwgNC4wKSAtIHY7XFxuXFx0XFx0dmVjNCBzID0gbiAqIG4gKiBuO1xcblxcdFxcdGZsb2F0IHggPSBzLng7XFxuXFx0XFx0ZmxvYXQgeSA9IHMueSAtIDQuMCAqIHMueDtcXG5cXHRcXHRmbG9hdCB6ID0gcy56IC0gNC4wICogcy55ICsgNi4wICogcy54O1xcblxcdFxcdGZsb2F0IHcgPSA2LjAgLSB4IC0geSAtIHo7XFxuXFx0XFx0cmV0dXJuIHZlYzQoeCwgeSwgeiwgdyk7XFxuXFx0fVxcblxcblxcdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNTAxMDgxL2VmZmljaWVudC1iaWN1YmljLWZpbHRlcmluZy1jb2RlLWluLWdsc2xcXG5cXHR2ZWM0IHRleHR1cmVCaWN1YmljKHNhbXBsZXIyRCB0LCB2ZWMyIHRleENvb3JkcywgdmVjMiB0ZXh0dXJlU2l6ZSkge1xcblxcdFxcdHZlYzIgaW52VGV4U2l6ZSA9IDEuMCAvIHRleHR1cmVTaXplO1xcblxcdFxcdHRleENvb3JkcyA9IHRleENvb3JkcyAqIHRleHR1cmVTaXplIC0gMC41O1xcblxcdFxcdHZlYzIgZnh5ID0gZnJhY3QodGV4Q29vcmRzKTtcXG5cXHRcXHR0ZXhDb29yZHMgLT0gZnh5O1xcblxcdFxcdHZlYzQgeGN1YmljID0gY3ViaWMoZnh5LngpO1xcblxcdFxcdHZlYzQgeWN1YmljID0gY3ViaWMoZnh5LnkpO1xcblxcdFxcdHZlYzQgYyA9IHRleENvb3Jkcy54eHl5ICsgdmVjMiAoLTAuNSwgMS41KS54eXh5O1xcblxcdFxcdHZlYzQgcyA9IHZlYzQoeGN1YmljLnh6ICsgeGN1YmljLnl3LCB5Y3ViaWMueHogKyB5Y3ViaWMueXcpO1xcblxcdFxcdHZlYzQgb2Zmc2V0ID0gYyArIHZlYzQgKHhjdWJpYy55dywgeWN1YmljLnl3KSAvIHM7XFxuXFx0XFx0b2Zmc2V0ICo9IGludlRleFNpemUueHh5eTtcXG5cXHRcXHR2ZWM0IHNhbXBsZTAgPSB0ZXh0dXJlMkQodCwgb2Zmc2V0Lnh6KTtcXG5cXHRcXHR2ZWM0IHNhbXBsZTEgPSB0ZXh0dXJlMkQodCwgb2Zmc2V0Lnl6KTtcXG5cXHRcXHR2ZWM0IHNhbXBsZTIgPSB0ZXh0dXJlMkQodCwgb2Zmc2V0Lnh3KTtcXG5cXHRcXHR2ZWM0IHNhbXBsZTMgPSB0ZXh0dXJlMkQodCwgb2Zmc2V0Lnl3KTtcXG5cXHRcXHRmbG9hdCBzeCA9IHMueCAvIChzLnggKyBzLnkpO1xcblxcdFxcdGZsb2F0IHN5ID0gcy56IC8gKHMueiArIHMudyk7XFxuXFx0XFx0cmV0dXJuIG1peChcXG5cXHRcXHRtaXgoc2FtcGxlMywgc2FtcGxlMiwgc3gpLCBtaXgoc2FtcGxlMSwgc2FtcGxlMCwgc3gpLCBzeSk7XFxuXFx0fVxcblxcbiNlbmRpZlxcblxcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdFNoYWRvd1xcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbiNpZmRlZiBERVBUSFxcblxcblxcdHZhcnlpbmcgdmVjMiB2SGlnaFByZWNpc2lvblpXO1xcblxcdHVuaWZvcm0gZmxvYXQgY2FtZXJhTmVhcjtcXG5cXHR1bmlmb3JtIGZsb2F0IGNhbWVyYUZhcjtcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX1NIQURPV01BUFxcblxcbiNpZiBOVU1fRElSX0xJR0hUX1NIQURPV1MgPiAwXFxuXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0aW9uYWxTaGFkb3dNYXBbIE5VTV9ESVJfTElHSFRfU0hBRE9XUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVF9TSEFET1dTIF07XFxuXFxuXFx0XFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHRTaGFkb3cge1xcblxcdFxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0XFx0ZmxvYXQgc2hhZG93Tm9ybWFsQmlhcztcXG5cXHRcXHRcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dW5pZm9ybSBEaXJlY3Rpb25hbExpZ2h0U2hhZG93IGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dzWyBOVU1fRElSX0xJR0hUX1NIQURPV1MgXTtcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHQjZGVmaW5lIFNIQURPV19TQU1QTEVfQ09VTlQgNFxcblxcblxcdHZlYzIgcG9pc3NvbkRpc2tbIFNIQURPV19TQU1QTEVfQ09VTlQgXTtcXG5cXG5cXHR2b2lkIGluaXRQb2lzc29uRGlzayggZmxvYXQgc2VlZCApIHtcXG5cXG5cXHRcXHRmbG9hdCByID0gMC4xO1xcblxcdFxcdGZsb2F0IHJTdGVwID0gKDEuMCAtIHIpIC8gZmxvYXQoIFNIQURPV19TQU1QTEVfQ09VTlQgKTtcXG5cXG5cXHRcXHRmbG9hdCBhbmcgPSByYW5kb20oIGdsX0ZyYWdDb29yZC54eSAqIDAuMDEgKyBzaW4oIHRpbWUgKSApICogUEkyICogMS4wO1xcblxcdFxcdGZsb2F0IGFuZ1N0ZXAgPSAoICggUEkyICogMTEuMCApIC8gZmxvYXQoIFNIQURPV19TQU1QTEVfQ09VTlQgKSApO1xcblxcdFxcdFxcblxcdFxcdGZvciggaW50IGkgPSAwOyBpIDwgU0hBRE9XX1NBTVBMRV9DT1VOVDsgaSsrICkge1xcblxcblxcdFxcdFxcdHBvaXNzb25EaXNrWyBpIF0gPSB2ZWMyKFxcblxcdFxcdFxcdFxcdHNpbiggYW5nICksXFxuXFx0XFx0XFx0XFx0Y29zKCBhbmcgKVxcblxcdFxcdFxcdCkgKiBwb3coIHIsIDAuNzUgKTtcXG5cXG5cXHRcXHRcXHRyICs9IHJTdGVwO1xcblxcdFxcdFxcdGFuZyArPSBhbmdTdGVwO1xcblxcdFxcdH1cXG5cXHRcXHRcXG5cXHR9XFxuXFxuXFx0dmVjMiBjb21wYWlyU2hhZG93TWFwRGVwdGgoIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwVVYsIGZsb2F0IGRlcHRoICkge1xcblxcblxcdFxcdGlmKCBzaGFkb3dNYXBVVi54IDwgMC4wIHx8IHNoYWRvd01hcFVWLnggPiAxLjAgfHwgc2hhZG93TWFwVVYueSA8IDAuMCB8fCBzaGFkb3dNYXBVVi55ID4gMS4wICkge1xcblxcblxcdFxcdFxcdHJldHVybiB2ZWMyKCAxLjAsIDAuMCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmbG9hdCBzaGFkb3dNYXBEZXB0aCA9IHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcCwgc2hhZG93TWFwVVYgKSApO1xcblxcblxcdFxcdGlmKCAwLjAgPj0gc2hhZG93TWFwRGVwdGggfHwgc2hhZG93TWFwRGVwdGggPj0gMS4wICkge1xcblxcblxcdFxcdFxcdHJldHVybiB2ZWMyKCAxLjAsIDAuMCApO1xcblxcblxcdFxcdH1cXG5cXHRcXHRcXG5cXHRcXHRmbG9hdCBzaGFkb3cgPSBkZXB0aCA8PSBzaGFkb3dNYXBEZXB0aCA/IDEuMCA6IDAuMDtcXG5cXG5cXHRcXHRyZXR1cm4gdmVjMiggc2hhZG93LCBzaGFkb3dNYXBEZXB0aCApO1xcblxcdFxcdFxcblxcdH1cXG5cXG5cXHRmbG9hdCBzaGFkb3dNYXBQQ0YoIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzQgc2hhZG93TWFwQ29vcmQsIHZlYzIgc2hhZG93U2l6ZSApIHtcXG5cXG5cXHRcXHRmbG9hdCBzaGFkb3cgPSAwLjA7XFxuXFx0XFx0XFxuXFx0XFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBTSEFET1dfU0FNUExFX0NPVU5UOyBpICsrICApIHtcXG5cXHRcXHRcXHRcXG5cXHRcXHRcXHR2ZWMyIG9mZnNldCA9IHBvaXNzb25EaXNrWyBpIF0gKiBzaGFkb3dTaXplOyBcXG5cXG5cXHRcXHRcXHRzaGFkb3cgKz0gY29tcGFpclNoYWRvd01hcERlcHRoKCBzaGFkb3dNYXAsIHNoYWRvd01hcENvb3JkLnh5ICsgb2Zmc2V0LCBzaGFkb3dNYXBDb29yZC56ICkueDtcXG5cXHRcXHRcXHRcXG5cXHRcXHR9XFxuXFxuXFx0XFx0c2hhZG93IC89IGZsb2F0KCBTSEFET1dfU0FNUExFX0NPVU5UICk7XFxuXFxuXFx0XFx0cmV0dXJuIHNoYWRvdztcXG5cXG5cXHR9XFxuXFxuXFx0ZmxvYXQgZ2V0U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IGJpYXMsIHZlYzQgc2hhZG93TWFwQ29vcmQgKSB7XFxuXFx0XFx0XFxuXFx0XFx0c2hhZG93TWFwQ29vcmQueHl6IC89IHNoYWRvd01hcENvb3JkLnc7XFxuXFx0XFx0c2hhZG93TWFwQ29vcmQueiArPSBiaWFzIC0gMC4wMDAxO1xcblxcblxcdFxcdGluaXRQb2lzc29uRGlzayh0aW1lKTtcXG5cXG5cXHRcXHR2ZWMyIHNoYWRvd1NpemUgPSAxLjAgLyBzaGFkb3dNYXBTaXplO1xcblxcblxcdFxcdHJldHVybiBzaGFkb3dNYXBQQ0YoIHNoYWRvd01hcCwgc2hhZG93TWFwQ29vcmQsIHNoYWRvd1NpemUgKTtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0UkVcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG52YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG52YXJ5aW5nIHZlYzMgdlZpZXdOb3JtYWw7XFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zO1xcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3M7XFxuXFxuZmxvYXQgZ2d4KCBmbG9hdCBkTkgsIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRcXG5cXHRmbG9hdCBhMiA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcXG5cXHRhMiA9IGEyICogYTI7XFxuXFx0ZmxvYXQgZE5IMiA9IGROSCAqIGROSDtcXG5cXG5cXHRpZiggZE5IMiA8PSAwLjAgKSByZXR1cm4gMC4wO1xcblxcblxcdHJldHVybiBhMiAvICggUEkgKiBwb3coIGROSDIgKiAoIGEyIC0gMS4wICkgKyAxLjAsIDIuMCkgKTtcXG5cXG59XFxuXFxudmVjMyBsYW1iZXJ0KCB2ZWMzIGRpZmZ1c2VDb2xvciApIHtcXG5cXG5cXHRyZXR1cm4gZGlmZnVzZUNvbG9yIC8gUEk7XFxuXFxufVxcblxcbmZsb2F0IGdTY2hsaWNrKCBmbG9hdCBkLCBmbG9hdCBrICkge1xcblxcblxcdGlmKCBkID09IDAuMCApIHJldHVybiAwLjA7XFxuXFxuXFx0cmV0dXJuIGQgLyAoIGQgKiAoIDEuMCAtIGsgKSArIGsgKTtcXG5cXHRcXG59XFxuXFxuZmxvYXQgZ1NtaXRoKCBmbG9hdCBkTlYsIGZsb2F0IGROTCwgZmxvYXQgcm91Z2huZXNzICkge1xcblxcblxcdGZsb2F0IGsgPSBjbGFtcCggcm91Z2huZXNzICogc3FydCggMi4wIC8gUEkgKSwgMC4wLCAxLjAgKTtcXG5cXG5cXHRyZXR1cm4gZ1NjaGxpY2soIGROViwgayApICogZ1NjaGxpY2soIGROTCwgayApO1xcblxcdFxcbn1cXG5cXG5mbG9hdCBmcmVzbmVsKCBmbG9hdCBkICkge1xcblxcdFxcblxcdGZsb2F0IGYwID0gMC4wNDtcXG5cXG5cXHRyZXR1cm4gZjAgKyAoIDEuMCAtIGYwICkgKiBwb3coIDEuMCAtIGQsIDUuMCApO1xcblxcbn1cXG5cXG52ZWMzIFJFKCBHZW9tZXRyeSBnZW8sIE1hdGVyaWFsIG1hdCwgTGlnaHQgbGlnaHQpIHtcXG5cXG5cXHR2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsaWdodC5kaXJlY3Rpb24gKTtcXG5cXHR2ZWMzIGhhbGZWZWMgPSBub3JtYWxpemUoIGdlby52aWV3RGlyICsgbGlnaHREaXIgKTtcXG5cXG5cXHRmbG9hdCBkTEggPSBjbGFtcCggZG90KCBsaWdodERpciwgaGFsZlZlYyApLCAwLjAsIDEuMCApO1xcblxcdGZsb2F0IGROSCA9IGNsYW1wKCBkb3QoIGdlby5ub3JtYWwsIGhhbGZWZWMgKSwgMC4wLCAxLjAgKTtcXG5cXHRmbG9hdCBkTlYgPSBjbGFtcCggZG90KCBnZW8ubm9ybWFsLCBnZW8udmlld0RpciApLCAwLjAsIDEuMCApO1xcblxcdGZsb2F0IGROTCA9IGNsYW1wKCBkb3QoIGdlby5ub3JtYWwsIGxpZ2h0RGlyKSwgMC4wLCAxLjAgKTtcXG5cXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBsaWdodC5jb2xvciAqIGROTDtcXG5cXG5cXHQvLyBkaWZmdXNlXFxuXFx0dmVjMyBkaWZmdXNlID0gbGFtYmVydCggbWF0LmRpZmZ1c2VDb2xvciApICogaXJyYWRpYW5jZTtcXG5cXG5cXHQvLyBzcGVjdWxhclxcblxcdGZsb2F0IEQgPSBnZ3goIGROSCwgbWF0LnJvdWdobmVzcyApO1xcblxcdGZsb2F0IEcgPSBnU21pdGgoIGROViwgZE5MLCBtYXQucm91Z2huZXNzICk7XFxuXFx0ZmxvYXQgRiA9IGZyZXNuZWwoIGRMSCApO1xcblxcdFxcblxcdHZlYzMgc3BlY3VsYXIgPSAoKCBEICogRyAqIEYgKSAvICggNC4wICogZE5MICogZE5WICsgMC4wMDAxICkgKiBtYXQuc3BlY3VsYXJDb2xvciApICogaXJyYWRpYW5jZTsgXFxuXFxuXFx0dmVjMyBjID0gdmVjMyggMC4wICk7XFxuXFx0YyArPSBkaWZmdXNlICogKCAxLjAgLSBGICkgKyBzcGVjdWxhcjtcXG5cXG5cXHRyZXR1cm4gYztcXG5cXG59XFxuXFxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0TWFpblxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcbnZvaWQgbWFpbiggdm9pZCApIHtcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHRNYXRlcmlhbFxcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdE1hdGVyaWFsIG1hdDtcXG5cXG5cXHQjaWZkZWYgVVNFX01BUFxcblxcblxcdFxcdHZlYzQgY29sb3IgPSBMaW5lYXJUb3NSR0IoIHRleHR1cmUyRCggbWFwLCB2VXYgKSApO1xcblxcdFxcdG1hdC5hbGJlZG8gPSBjb2xvci54eXo7XFxuXFx0XFx0bWF0Lm9wYWNpdHkgPSBjb2xvci53O1xcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0bWF0LmFsYmVkbyA9IGNvbG9yLnh5ejtcXG5cXHRcXHRtYXQub3BhY2l0eSA9IDEuMDtcXG5cXHRcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWZkZWYgVVNFX1JPVUdITkVTU19NQVBcXG5cXG5cXHRcXHRtYXQucm91Z2huZXNzID0gdGV4dHVyZTJEKCByb3VnaG5lc3NNYXAsIHZVdiApLnk7XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHRtYXQucm91Z2huZXNzID0gcm91Z2huZXNzO1xcblxcdFxcblxcdCNlbmRpZlxcblxcblxcdCNpZmRlZiBVU0VfTUVUQUxORVNTX01BUFxcblxcblxcdFxcdG1hdC5tZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdlV2ICkuejtcXG5cXG5cXHQjZWxzZVxcblxcblxcdFxcdG1hdC5tZXRhbG5lc3MgPSBtZXRhbG5lc3M7XFxuXFx0XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIFVTRV9BTFBIQV9NQVBcXG5cXG5cXHRcXHRtYXQub3BhY2l0eSA9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLng7XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHRtYXQub3BhY2l0eSAqPSBvcGFjaXR5O1xcblxcblxcdCNlbmRpZlxcblxcdFxcblxcdC8vIGlmKCBtYXQub3BhY2l0eSA8IDAuNSApIGRpc2NhcmQ7XFxuXFxuXFx0bWF0LmRpZmZ1c2VDb2xvciA9IG1peCggbWF0LmFsYmVkbywgdmVjMyggMC4wLCAwLjAsIDAuMCApLCBtYXQubWV0YWxuZXNzICk7XFxuXFx0bWF0LnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIDEuMCwgMS4wLCAxLjAgKSwgbWF0LmFsYmVkbywgbWF0Lm1ldGFsbmVzcyApO1xcblxcblxcdC8vIG91dHB1dFxcblxcdHZlYzMgb3V0Q29sb3IgPSB2ZWMzKCAwLjAgKTtcXG5cXHRmbG9hdCBvdXRPcGFjaXR5ID0gbWF0Lm9wYWNpdHk7XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0RGVwdGhcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXG5cXHQjaWZkZWYgREVQVEhcXG5cXG5cXHRcXHRmbG9hdCBmcmFnQ29vcmRaID0gMC41ICogdkhpZ2hQcmVjaXNpb25aVy54IC8gdkhpZ2hQcmVjaXNpb25aVy55ICsgMC41O1xcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggZnJhZ0Nvb3JkWiApO1xcblxcdFxcdHJldHVybjtcXG5cXHRcXG5cXHQjZW5kaWZcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHRHZW9tZXRyeVxcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdGZsb2F0IGZhY2VEaXJlY3Rpb24gPSBnbF9Gcm9udEZhY2luZyA/IDEuMCA6IC0xLjA7XFxuXFxuXFx0R2VvbWV0cnkgZ2VvO1xcblxcdGdlby5wb3MgPSAtdlZpZXdQb3M7XFxuXFx0Z2VvLnBvc1dvcmxkID0gdldvcmxkUG9zO1xcblxcdGdlby52aWV3RGlyID0gbm9ybWFsaXplKCB2Vmlld1BvcyApO1xcblxcdGdlby52aWV3RGlyV29ybGQgPSBub3JtYWxpemUoIGdlby5wb3NXb3JsZCAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFx0Z2VvLm5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApICogZmFjZURpcmVjdGlvbjtcXG5cXG5cXHQjaWZkZWYgVVNFX05PUk1BTF9NQVBcXG5cXHRcXHRcXG5cXHRcXHR2ZWMzIHRhbmdlbnQgPSBub3JtYWxpemUoIHZUYW5nZW50ICk7XFxuXFx0XFx0dmVjMyBiaXRhbmdlbnQgPSBub3JtYWxpemUoIHZCaXRhbmdlbnQgKTtcXG5cXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXFx0XFx0XFx0dGFuZ2VudCAqPSBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdFxcdGJpdGFuZ2VudCAqPSBmYWNlRGlyZWN0aW9uO1xcblxcdFxcdFxcblxcdFxcdCNlbmRpZlxcblxcdFxcdFxcblxcdFxcdG1hdDMgdlRCTiA9IG1hdDMoIHRhbmdlbnQsIGJpdGFuZ2VudCwgZ2VvLm5vcm1hbCApO1xcblxcdFxcdFxcblxcdFxcdHZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXo7XFxuXFx0XFx0bWFwTiA9IG1hcE4gKiAyLjAgLSAxLjA7XFxuXFx0XFx0Z2VvLm5vcm1hbCA9IG5vcm1hbGl6ZSggdlRCTiAqIG1hcE4gKTtcXG5cXG5cXHQjZW5kaWZcXG5cXHRcXG5cXHRnZW8ubm9ybWFsV29ybGQgPSBub3JtYWxpemUoICggdmVjNCggZ2VvLm5vcm1hbCwgMC4wICkgKiB2aWV3TWF0cml4ICkueHl6ICk7XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0TGlnaHRpbmdcXG5cXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cXG5cXHRcXG5cXHRMaWdodCBsaWdodDtcXG5cXG5cXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFxuXFx0XFx0ZmxvYXQgc2hhZG93O1xcblxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3Bfc3RhcnRcXG5cXHRcXHRcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRsaWdodC5kaXJlY3Rpb24gPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdLmRpcmVjdGlvbjtcXG5cXHRcXHRcXHRcXHRsaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0uY29sb3I7XFxuXFx0XFx0XFx0XFx0c2hhZG93ID0gMS4wO1xcblxcblxcdFxcdFxcdFxcdCNpZiBkZWZpbmVkKCBVU0VfU0hBRE9XTUFQICkgJiYgTlVNX0RJUl9MSUdIVF9TSEFET1dTID4gMFxcblxcblxcdFxcdFxcdFxcdFxcdHNoYWRvdyA9IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodFNoYWRvd3NbIGkgXS5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93c1sgaSBdLnNoYWRvd0JpYXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHQjZW5kaWZcXG5cXG5cXHRcXHRcXHRcXHRvdXRDb2xvciArPSBSRSggZ2VvLCBtYXQsIGxpZ2h0ICkgKiBzaGFkb3c7XFxuXFx0XFx0XFx0XFx0XFxuXFx0XFx0XFx0fVxcblxcdFxcdCNwcmFnbWEgdW5yb2xsX2xvb3BfZW5kXFxuXFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXFx0XFx0UG9pbnRMaWdodCBwTGlnaHQ7XFxuXFx0XFx0dmVjMyB2O1xcblxcdFxcdGZsb2F0IGQ7XFxuXFx0XFx0ZmxvYXQgYXR0ZW51YXRpb247XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9zdGFydFxcblxcblxcdFxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR2ID0gcExpZ2h0LnBvc2l0aW9uIC0gZ2VvLnBvcztcXG5cXHRcXHRcXHRcXHRkID0gbGVuZ3RoKCB2ICk7XFxuXFx0XFx0XFx0XFx0bGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2ICk7XFxuXFx0XFx0XFxuXFx0XFx0XFx0XFx0bGlnaHQuY29sb3IgPSBwTGlnaHQuY29sb3I7XFxuXFxuXFx0XFx0XFx0XFx0aWYoIHBMaWdodC5kaXN0YW5jZSA+IDAuMCAmJiBwTGlnaHQuZGVjYXkgPiAwLjAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YXR0ZW51YXRpb24gPSBwb3coIGNsYW1wKCAtZCAvIHBMaWdodC5kaXN0YW5jZSArIDEuMCwgMC4wLCAxLjAgKSwgcExpZ2h0LmRlY2F5ICk7XFxuXFx0XFx0XFx0XFx0XFx0bGlnaHQuY29sb3IgKj0gYXR0ZW51YXRpb247XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdG91dENvbG9yICs9IFJFKCBnZW8sIG1hdCwgbGlnaHQgKTtcXG5cXHRcXHRcXHRcXHRcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFxuXFx0XFx0I3ByYWdtYSB1bnJvbGxfbG9vcF9lbmRcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVl9NQVAgKSB8fCBkZWZpbmVkKCBJU19SRUZMRUNUSU9OUExBTkUgKVxcblxcblxcdFxcdGZsb2F0IGROViA9IGNsYW1wKCBkb3QoIGdlby5ub3JtYWwsIGdlby52aWV3RGlyICksIDAuMCwgMS4wICk7XFxuXFx0XFx0ZmxvYXQgRUYgPSBmcmVzbmVsKCBkTlYgKTtcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHRFbnZpcm9ubWVudCBMaWdodGluZ1xcblxcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdCNpZmRlZiBVU0VfRU5WX01BUFxcblxcblxcdFxcdHZlYzMgcmVmRGlyID0gcmVmbGVjdCggZ2VvLnZpZXdEaXJXb3JsZCwgZ2VvLm5vcm1hbFdvcmxkICk7XFxuXFx0XFx0cmVmRGlyLnggKj0gLTEuMDtcXG5cXHRcXG5cXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggZW52TWFwLCBnZW8ubm9ybWFsV29ybGQsIDEuMCApICogaWJsSW50ZW5zaXR5ICogZW52TWFwSW50ZW5zaXR5O1xcblxcdFxcdG91dENvbG9yICs9IG1hdC5kaWZmdXNlQ29sb3IgKiBlbnZNYXBDb2xvci54eXogKiAoIDEuMCAtIG1hdC5tZXRhbG5lc3MgKTtcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHRSZWZsZWN0aW9uXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFx0XFxuXFx0I2lmZGVmIElTX1JFRkxFQ1RJT05QTEFORVxcblxcdFxcblxcdFxcdHZlYzIgcmVmVVYgPSBnbF9GcmFnQ29vcmQueHkgLyByZW5kZXJSZXNvbHV0aW9uO1xcblxcblxcdFxcdHJlZlVWLnggKz0gZ2VvLm5vcm1hbC54ICogMC41O1xcblxcblxcdFxcdGZsb2F0IGwgPSAobWF0LnJvdWdobmVzcyApICogMS42ICogUkVGX01JUE1BUF9MRVZFTDtcXG5cXG5cXHRcXHRmbG9hdCBvZmZzZXQxID0gZmxvb3IoIGwgKTtcXG5cXHRcXHRmbG9hdCBvZmZzZXQyID0gb2Zmc2V0MSArIDEuMDtcXG5cXHRcXHRmbG9hdCBibGVuZCA9IGZyYWN0KCBsICk7XFxuXFx0XFx0XFxuXFx0XFx0dmVjMiBydXYxID0gZ2V0UmVmTWlwbWFwVVYoIHJlZlVWLCBvZmZzZXQxICk7XFxuXFx0XFx0dmVjMiBydXYyID0gZ2V0UmVmTWlwbWFwVVYoIHJlZlVWLCBvZmZzZXQyICk7XFxuXFxuXFx0XFx0dmVjMyByZWYxID0gdGV4dHVyZUJpY3ViaWMoIHJlZmxlY3Rpb25UZXgsIHJ1djEsIG1pcE1hcFJlc29sdXRpb24gKS54eXo7XFxuXFx0XFx0dmVjMyByZWYyID0gdGV4dHVyZUJpY3ViaWMoIHJlZmxlY3Rpb25UZXgsIHJ1djIsIG1pcE1hcFJlc29sdXRpb24gKS54eXo7XFxuXFxuXFx0XFx0dmVjMyByZWYgPSBtYXQuc3BlY3VsYXJDb2xvciAqIG1peCggcmVmMSwgcmVmMiwgYmxlbmQgKTtcXG5cXG5cXHRcXHRvdXRDb2xvciA9IG1peChcXG5cXHRcXHRcXHRvdXRDb2xvciArIHJlZiAqIG1hdC5tZXRhbG5lc3MsXFxuXFx0XFx0XFx0cmVmLFxcblxcdFxcdFxcdEVGXFxuXFx0XFx0KTtcXG5cXG5cXHQjZWxpZiBkZWZpbmVkKCBVU0VfRU5WX01BUCApXFxuXFx0XFxuXFx0XFx0dmVjMyBlbnYgPSBtYXQuc3BlY3VsYXJDb2xvciAqIHRleHR1cmVDdWJlVVYoIGVudk1hcCwgcmVmRGlyLCBtYXQucm91Z2huZXNzICkueHl6ICogZW52TWFwSW50ZW5zaXR5O1xcblxcdFxcblxcdFxcdG91dENvbG9yID0gbWl4KFxcblxcdFxcdFxcdG91dENvbG9yICsgZW52ICogbWF0Lm1ldGFsbmVzcyxcXG5cXHRcXHRcXHRlbnYsXFxuXFx0XFx0XFx0RUZcXG5cXHRcXHQpO1xcblxcdFxcblxcdCNlbmRpZlxcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdFxcdEVtaXNzaW9uXFxuXFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuXFx0I2lmZGVmIFVTRV9FTUlTU0lPTl9NQVBcXG5cXG5cXHRcXHRvdXRDb2xvciArPSBMaW5lYXJUb3NSR0IoIHRleHR1cmUyRCggZW1pc3Npb25NYXAsIHZVdiApICkueHl6O1xcblxcdFxcblxcdCNlbHNlXFxuXFxuXFx0XFx0b3V0Q29sb3IgKz0gZW1pc3Npb247XFxuXFxuXFx0I2VuZGlmXFxuXFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Q29sb3IsIG91dE9wYWNpdHkgKTtcXG5cXG59XCI7IiwiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xyXG5pbXBvcnQgKiBhcyBPUkUgZnJvbSAnb3JlLXRocmVlJztcclxuXHJcbmltcG9ydCBwb3dlclZlcnQgZnJvbSAnLi9zaGFkZXJzL3Bvd2VyLnZzJztcclxuaW1wb3J0IHBvd2VyRnJhZyBmcm9tICcuL3NoYWRlcnMvcG93ZXIuZnMnO1xyXG5cclxuZXhwb3J0IHR5cGUgUG93ZXJNZXNoTWF0ZXJpYWxUeXBlID0gJ2NvbG9yJyB8ICdkZXB0aCcgfCAnY29jJ1xyXG5leHBvcnQgY2xhc3MgUG93ZXJNZXNoIGV4dGVuZHMgVEhSRUUuU2tpbm5lZE1lc2g8VEhSRUUuQnVmZmVyR2VvbWV0cnksIFRIUkVFLlNoYWRlck1hdGVyaWFsPiB7XHJcblxyXG5cdHByb3RlY3RlZCBjb21tb25Vbmlmb3JtczogT1JFLlVuaWZvcm1zO1xyXG5cclxuXHQvLyBlbnZNYXBcclxuXHRwcm90ZWN0ZWQgZW52TWFwUmVzb2x1dGlvbjogbnVtYmVyO1xyXG5cdHByb3RlY3RlZCBlbnZNYXBSZW5kZXJUYXJnZXQ6IFRIUkVFLldlYkdMQ3ViZVJlbmRlclRhcmdldDtcclxuXHRwcm90ZWN0ZWQgZW52TWFwQ2FtZXJhOiBUSFJFRS5DdWJlQ2FtZXJhO1xyXG5cdHByb3RlY3RlZCBlbnZNYXBVcGRhdGU6IGJvb2xlYW47XHJcblx0cHJvdGVjdGVkIGVudk1hcFNyYzogVEhSRUUuQ3ViZVRleHR1cmUgfCBUSFJFRS5UZXh0dXJlIHwgbnVsbDtcclxuXHJcblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5OiBUSFJFRS5CdWZmZXJHZW9tZXRyeSwgbWF0ZXJpYWxPcHRpb24/OiBUSFJFRS5TaGFkZXJNYXRlcmlhbFBhcmFtZXRlcnMsIG92ZXJyaWRlPzogYm9vbGVhbiApO1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnk6IFRIUkVFLlNraW5uZWRNZXNoLCBtYXRlcmlhbE9wdGlvbj86IFRIUkVFLlNoYWRlck1hdGVyaWFsUGFyYW1ldGVycywgb3ZlcnJpZGU/OiBib29sZWFuICk7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBtZXNoOiBUSFJFRS5NZXNoLCBtYXRlcmlhbE9wdGlvbj86IFRIUkVFLlNoYWRlck1hdGVyaWFsUGFyYW1ldGVycywgb3ZlcnJpZGU/OiBib29sZWFuICk7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCBnZW9NZXNoOiBUSFJFRS5CdWZmZXJHZW9tZXRyeSB8IFRIUkVFLk1lc2ggfCBUSFJFRS5Ta2lubmVkTWVzaCwgbWF0ZXJpYWxPcHRpb24/OiBUSFJFRS5TaGFkZXJNYXRlcmlhbFBhcmFtZXRlcnMsIG92ZXJyaWRlPzogYm9vbGVhbiApIHtcclxuXHJcblx0XHRtYXRlcmlhbE9wdGlvbiA9IG1hdGVyaWFsT3B0aW9uIHx8IHt9O1xyXG5cclxuXHRcdGxldCB1bmkgPSBPUkUuVW5pZm9ybXNMaWIubWVyZ2VVbmlmb3JtcyggbWF0ZXJpYWxPcHRpb24udW5pZm9ybXMgfHwge30sIHtcclxuXHRcdFx0ZW52TWFwOiB7XHJcblx0XHRcdFx0dmFsdWU6IG51bGxcclxuXHRcdFx0fSxcclxuXHRcdFx0ZW52TWFwSW50ZW5zaXR5OiB7XHJcblx0XHRcdFx0dmFsdWU6IG51bGxcclxuXHRcdFx0fSxcclxuXHRcdFx0aWJsSW50ZW5zaXR5OiB7XHJcblx0XHRcdFx0dmFsdWU6IG51bGxcclxuXHRcdFx0fSxcclxuXHRcdFx0bWF4TG9kTGV2ZWw6IHtcclxuXHRcdFx0XHR2YWx1ZTogMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzaGFkb3dMaWdodE1vZGVsVmlld01hdHJpeDoge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpXHJcblx0XHRcdH0sXHJcblx0XHRcdHNoYWRvd0xpZ2h0UHJvamVjdGlvbk1hdHJpeDoge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpXHJcblx0XHRcdH0sXHJcblx0XHRcdHNoYWRvd0xpZ2h0RGlyZWN0aW9uOiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IzKClcclxuXHRcdFx0fSxcclxuXHRcdFx0c2hhZG93TGlnaHRDYW1lcmFDbGlwOiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKClcclxuXHRcdFx0fSxcclxuXHRcdFx0c2hhZG93TWFwOiB7XHJcblx0XHRcdFx0dmFsdWU6IG51bGxcclxuXHRcdFx0fSxcclxuXHRcdFx0c2hhZG93TWFwU2l6ZToge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMigpXHJcblx0XHRcdH0sXHJcblx0XHRcdHNoYWRvd01hcFJlc29sdXRpb246IHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoKVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRzaGFkb3dMaWdodFNpemU6IHtcclxuXHRcdFx0XHR2YWx1ZTogMS4wXHJcblx0XHRcdH0sXHJcblx0XHRcdGNhbWVyYU5lYXI6IHtcclxuXHRcdFx0XHR2YWx1ZTogMC4wMVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRjYW1lcmFGYXI6IHtcclxuXHRcdFx0XHR2YWx1ZTogMTAwMC4wXHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIGRlZmF1bHQgcHJvcHNcclxuXHRcdFx0Y29sb3I6IHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAxLjAsIDEuMCwgMS4wIClcclxuXHRcdFx0fSxcclxuXHRcdFx0bWV0YWxuZXNzOiB7XHJcblx0XHRcdFx0dmFsdWU6IDBcclxuXHRcdFx0fSxcclxuXHRcdFx0cm91Z2huZXNzOiB7XHJcblx0XHRcdFx0dmFsdWU6IDAuNVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRvcGFjaXR5OiB7XHJcblx0XHRcdFx0dmFsdWU6IDFcclxuXHRcdFx0fSxcclxuXHRcdFx0ZW1pc3Npb246IHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAwLjAsIDAuMCwgMC4wIClcclxuXHRcdFx0fVxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHVuaSA9IE9SRS5Vbmlmb3Jtc0xpYi5tZXJnZVVuaWZvcm1zKCB1bmksIFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIFRIUkVFLlVuaWZvcm1zTGliLmxpZ2h0cyApICk7XHJcblxyXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdEdlb21ldHJ5XHJcblx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0XHRsZXQgZ2VvOiBUSFJFRS5CdWZmZXJHZW9tZXRyeTtcclxuXHJcblx0XHRpZiAoICdpc0J1ZmZlckdlb21ldHJ5JyBpbiBnZW9NZXNoICkge1xyXG5cclxuXHRcdFx0Z2VvID0gZ2VvTWVzaDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCAnaXNNZXNoJyBpbiBnZW9NZXNoICkge1xyXG5cclxuXHRcdFx0Z2VvID0gZ2VvTWVzaC5nZW9tZXRyeTtcclxuXHJcblx0XHRcdGxldCBtYXQgPSAoIGdlb01lc2gubWF0ZXJpYWwgYXMgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdGlmICggbWF0LmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0Lm1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmkubWFwID0ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF0Lm1hcFxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0LmNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaS5jb2xvci52YWx1ZS5jb3B5KCBtYXQuY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG1hdC5yb3VnaG5lc3NNYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pLnJvdWdobmVzc01hcCA9IHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IG1hdC5yb3VnaG5lc3NNYXBcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pLnJvdWdobmVzcy52YWx1ZSA9IG1hdC5yb3VnaG5lc3M7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXQuYWxwaGFNYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pLmFscGhhTWFwID0ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF0LmFscGhhTWFwXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHVuaS5vcGFjaXR5LnZhbHVlID0gbWF0Lm9wYWNpdHk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBtYXQubWV0YWxuZXNzTWFwICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaS5tZXRhbG5lc3NNYXAgPSB7XHJcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXQubWV0YWxuZXNzTWFwXHJcblx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHVuaS5tZXRhbG5lc3MudmFsdWUgPSBtYXQubWV0YWxuZXNzO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggbWF0Lm5vcm1hbE1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmkubm9ybWFsTWFwID0ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF0Lm5vcm1hbE1hcFxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG1hdC5lbWlzc2l2ZU1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmkuZW1pc3Npb25NYXAgPSB7XHJcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXQuZW1pc3NpdmVNYXBcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pLmVtaXNzaW9uLnZhbHVlLmNvcHkoIG1hdC5lbWlzc2l2ZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGdlbyA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB0YW5nZW50c1xyXG5cclxuXHRcdGlmICggISBnZW8uZ2V0QXR0cmlidXRlKCAndGFuZ2VudCcgKSApIHtcclxuXHJcblx0XHRcdGlmIChcclxuXHRcdFx0XHRnZW8uZ2V0SW5kZXgoKSAmJlxyXG5cdFx0XHRcdGdlby5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKSAmJlxyXG5cdFx0XHRcdGdlby5nZXRBdHRyaWJ1dGUoICdub3JtYWwnICkgJiZcclxuXHRcdFx0XHRnZW8uZ2V0QXR0cmlidXRlKCAndXYnIClcclxuXHRcdFx0KSB7XHJcblxyXG5cdFx0XHRcdGdlby5jb21wdXRlVGFuZ2VudHMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdE1hdGVyaWFsXHJcblx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0XHRtYXRlcmlhbE9wdGlvbi51bmlmb3JtcyA9IHVuaTtcclxuXHJcblx0XHRsZXQgbWF0ID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XHJcblx0XHRcdHZlcnRleFNoYWRlcjogcG93ZXJWZXJ0LFxyXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogcG93ZXJGcmFnLFxyXG5cdFx0XHRsaWdodHM6IHRydWUsXHJcblx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxyXG5cdFx0XHRzaWRlOiBUSFJFRS5Eb3VibGVTaWRlLFxyXG5cdFx0XHRleHRlbnNpb25zOiB7XHJcblx0XHRcdFx0ZGVyaXZhdGl2ZXM6IHRydWUsXHJcblx0XHRcdH0sXHJcblx0XHRcdGRlZmluZXM6IHtcclxuXHRcdFx0fSxcclxuXHRcdFx0Li4ubWF0ZXJpYWxPcHRpb25cclxuXHRcdH0gKTtcclxuXHJcblx0XHRpZiAoIHVuaS5tYXAgKSB7XHJcblxyXG5cdFx0XHRtYXQuZGVmaW5lcy5VU0VfTUFQID0gJyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdW5pLnJvdWdobmVzc01hcCApIHtcclxuXHJcblx0XHRcdG1hdC5kZWZpbmVzLlVTRV9ST1VHSE5FU1NfTUFQID0gJyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdW5pLm1ldGFsbmVzc01hcCApIHtcclxuXHJcblx0XHRcdG1hdC5kZWZpbmVzLlVTRV9NRVRBTE5FU1NfTUFQID0gJyc7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdW5pLmFscGhhTWFwICkge1xyXG5cclxuXHRcdFx0bWF0LmRlZmluZXMuVVNFX0FMUEhBX01BUCA9ICcnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVuaS5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHRtYXQuZGVmaW5lcy5VU0VfTk9STUFMX01BUCA9ICcnO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVuaS5lbWlzc2lvbk1hcCApIHtcclxuXHJcblx0XHRcdG1hdC5kZWZpbmVzLlVTRV9FTUlTU0lPTl9NQVAgPSAnJztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3VwZXIoIGdlbywgbWF0ICk7XHJcblxyXG5cdFx0dGhpcy5uYW1lID0gZ2VvTWVzaC5uYW1lO1xyXG5cclxuXHRcdHRoaXMudXNlckRhdGEuY29sb3JNYXQgPSB0aGlzLm1hdGVyaWFsO1xyXG5cclxuXHRcdHRoaXMuY3VzdG9tRGVwdGhNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xyXG5cdFx0XHR2ZXJ0ZXhTaGFkZXI6IHBvd2VyVmVydCxcclxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IHBvd2VyRnJhZyxcclxuXHRcdFx0c2lkZTogVEhSRUUuRG91YmxlU2lkZSxcclxuXHRcdFx0bGlnaHRzOiB0cnVlLFxyXG5cdFx0XHRleHRlbnNpb25zOiB7XHJcblx0XHRcdFx0ZGVyaXZhdGl2ZXM6IHRydWVcclxuXHRcdFx0fSxcclxuXHRcdFx0Li4ubWF0ZXJpYWxPcHRpb24sXHJcblx0XHRcdGRlZmluZXM6IHtcclxuXHRcdFx0XHQuLi5tYXQuZGVmaW5lcyxcclxuXHRcdFx0XHQnREVQVEgnOiBcIlwiLFxyXG5cdFx0XHR9LFxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHRoaXMuY29tbW9uVW5pZm9ybXMgPSB1bmk7XHJcblxyXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRcdFRyYW5zZm9ybVxyXG5cdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdFx0aWYgKCAnaXNNZXNoJyBpbiBnZW9NZXNoICYmIG92ZXJyaWRlICkge1xyXG5cclxuXHRcdFx0Z2VvTWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcblxyXG5cdFx0XHRsZXQgY2hpbGRBcnJheSA9IGdlb01lc2guY2hpbGRyZW4uc2xpY2UoKTtcclxuXHJcblx0XHRcdGNoaWxkQXJyYXkuZm9yRWFjaCggY2hpbGQgPT4ge1xyXG5cclxuXHRcdFx0XHR0aGlzLmFkZCggY2hpbGQgKTtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdHRoaXMucG9zaXRpb24uY29weSggZ2VvTWVzaC5wb3NpdGlvbiApO1xyXG5cdFx0XHR0aGlzLnJvdGF0aW9uLmNvcHkoIGdlb01lc2gucm90YXRpb24gKTtcclxuXHRcdFx0dGhpcy5zY2FsZS5jb3B5KCBnZW9NZXNoLnNjYWxlICk7XHJcblxyXG5cdFx0XHRsZXQgcGFyZW50ID0gZ2VvTWVzaC5wYXJlbnQ7XHJcblxyXG5cdFx0XHRpZiAoIHBhcmVudCApIHtcclxuXHJcblx0XHRcdFx0cGFyZW50LmFkZCggdGhpcyApO1xyXG5cclxuXHRcdFx0XHRwYXJlbnQucmVtb3ZlKCBnZW9NZXNoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdFx0XHRBbmltYXRpb25cclxuXHRcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuXHRcdGlmICggXCJpc01lc2hcIiBpbiBnZW9NZXNoICkge1xyXG5cclxuXHRcdFx0Z2VvTWVzaC5hbmltYXRpb25zLmZvckVhY2goIGl0ZW0gPT4ge1xyXG5cclxuXHRcdFx0XHR0aGlzLmFuaW1hdGlvbnMucHVzaCggaXRlbSApO1xyXG5cclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0aWYgKCBcImlzU2tpbm5lZE1lc2hcIiBpbiBnZW9NZXNoICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb01lc2guc2tlbGV0b24gKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5za2VsZXRvbiA9IGdlb01lc2guc2tlbGV0b247XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuc2tlbGV0b24gPSBuZXcgVEhSRUUuU2tlbGV0b24oIFtdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdFx0XHRFbnZNYXBcclxuXHRcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuXHRcdHRoaXMuZW52TWFwU3JjID0gbnVsbDtcclxuXHRcdHRoaXMuZW52TWFwVXBkYXRlID0gZmFsc2U7XHJcblx0XHR0aGlzLmVudk1hcFJlc29sdXRpb24gPSAyNTY7XHJcblxyXG5cdFx0dGhpcy5lbnZNYXBSZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KCB0aGlzLmVudk1hcFJlc29sdXRpb24sIHtcclxuXHRcdFx0Zm9ybWF0OiBUSFJFRS5SR0JBRm9ybWF0LFxyXG5cdFx0XHRnZW5lcmF0ZU1pcG1hcHM6IHRydWUsXHJcblx0XHRcdG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLFxyXG5cdFx0XHRtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlclxyXG5cdFx0fSApO1xyXG5cclxuXHRcdHRoaXMuZW52TWFwQ2FtZXJhID0gbmV3IFRIUkVFLkN1YmVDYW1lcmEoIDAuMDAxLCAxMDAwLCB0aGlzLmVudk1hcFJlbmRlclRhcmdldCApO1xyXG5cdFx0dGhpcy5nZXRXb3JsZFBvc2l0aW9uKCB0aGlzLmVudk1hcENhbWVyYS5wb3NpdGlvbiApO1xyXG5cclxuXHRcdHRoaXMub25CZWZvcmVSZW5kZXIgPSAoIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhICkgPT4ge1xyXG5cclxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7XHJcblx0XHRcdFx0dHlwZTogJ2JlZm9yZVJlbmRlcicsXHJcblx0XHRcdFx0cmVuZGVyZXIsXHJcblx0XHRcdFx0c2NlbmUsXHJcblx0XHRcdFx0Y2FtZXJhXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggJ2JlZm9yZVJlbmRlcicsICggZTogVEhSRUUuRXZlbnQgKSA9PiB7XHJcblxyXG5cdFx0XHRsZXQgcmVuZGVyZXIgPSBlLnJlbmRlcmVyO1xyXG5cdFx0XHRsZXQgc2NlbmUgPSBlLnNjZW5lO1xyXG5cdFx0XHRsZXQgY2FtZXJhID0gZS5jYW1lcmE7XHJcblxyXG5cdFx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFx0XHRFbnZNYXBcclxuXHRcdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuZW52TWFwVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRsZXQgZW52TWFwUlQ6IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0IHwgbnVsbCA9IG51bGw7XHJcblxyXG5cdFx0XHRcdGxldCBwbXJlbUdlbmVyYXRvciA9IG5ldyBUSFJFRS5QTVJFTUdlbmVyYXRvciggcmVuZGVyZXIgKTtcclxuXHRcdFx0XHRwbXJlbUdlbmVyYXRvci5jb21waWxlRXF1aXJlY3Rhbmd1bGFyU2hhZGVyKCk7XHJcblxyXG5cdFx0XHRcdGlmICggdGhpcy5lbnZNYXBTcmMgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAnaXNDdWJlVGV4dHVyZScgaW4gdGhpcy5lbnZNYXBTcmMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRlbnZNYXBSVCA9IHBtcmVtR2VuZXJhdG9yLmZyb21DdWJlbWFwKCB0aGlzLmVudk1hcFNyYyApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRlbnZNYXBSVCA9IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIoIHRoaXMuZW52TWFwU3JjICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuZW52TWFwQ2FtZXJhLnVwZGF0ZSggcmVuZGVyZXIsIHNjZW5lICk7XHJcblx0XHRcdFx0XHRlbnZNYXBSVCA9IHBtcmVtR2VuZXJhdG9yLmZyb21DdWJlbWFwKCB0aGlzLmVudk1hcFJlbmRlclRhcmdldC50ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBlbnZtYXBcclxuXHRcdFx0XHRsZXQgZW52TWFwUmVzb2x1dGlvbiA9IGVudk1hcFJULmhlaWdodDtcclxuXHJcblx0XHRcdFx0Y29uc3QgbWF4TWlwID0gTWF0aC5yb3VuZCggTWF0aC5sb2cyKCBlbnZNYXBSZXNvbHV0aW9uICkgKSAtIDI7XHJcblx0XHRcdFx0Y29uc3QgdGV4ZWxIZWlnaHQgPSAxLjAgLyBlbnZNYXBSZXNvbHV0aW9uO1xyXG5cdFx0XHRcdGNvbnN0IHRleGVsV2lkdGggPSAxLjAgLyAoIDMgKiBNYXRoLm1heCggTWF0aC5wb3coIDIsIG1heE1pcCApLCA3ICogMTYgKSApO1xyXG5cclxuXHRcdFx0XHRtYXQuZGVmaW5lc1sgJ1VTRV9FTlZfTUFQJyBdID0gJyc7XHJcblx0XHRcdFx0bWF0LmRlZmluZXNbICdDVUJFVVZfTUFYX01JUCcgXSA9IG1heE1pcCArICcuMCc7XHJcblx0XHRcdFx0bWF0LmRlZmluZXNbICdDVUJFVVZfVEVYRUxfV0lEVEgnIF0gPSB0ZXhlbFdpZHRoICsgJyc7XHJcblx0XHRcdFx0bWF0LmRlZmluZXNbICdDVUJFVVZfVEVYRUxfSEVJR0hUJyBdID0gdGV4ZWxIZWlnaHQgKyAnJztcclxuXHJcblx0XHRcdFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBlbnZNYXBSVC50ZXh0dXJlO1xyXG5cdFx0XHRcdHRoaXMuZW52TWFwVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFx0XHREZXB0aFxyXG5cdFx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0XHRcdGlmICggY2FtZXJhLnVzZXJEYXRhLmRlcHRoQ2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1hdGVyaWFsID0gdGhpcy51c2VyRGF0YS5kZXB0aE1hdDtcclxuXHRcdFx0XHR0aGlzLmNvbW1vblVuaWZvcm1zLmNhbWVyYU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcclxuXHRcdFx0XHR0aGlzLmNvbW1vblVuaWZvcm1zLmNhbWVyYUZhci52YWx1ZSA9IGNhbWVyYS5mYXI7XHJcblxyXG5cdFx0XHRcdGlmICggISB0aGlzLm1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdFx0XHREaXNwb3NlXHJcblx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0XHRjb25zdCBvbkRpc3Bvc2UgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHR0aGlzLmVudk1hcFJlbmRlclRhcmdldC5kaXNwb3NlKCk7XHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG5cdFx0XHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuXHJcblx0XHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdEVudk1hcCAvIElCTFxyXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG5cclxuXHRwdWJsaWMgdXBkYXRlRW52TWFwKCBlbnZNYXA6IFRIUkVFLkN1YmVUZXh0dXJlIHwgVEhSRUUuVGV4dHVyZSB8IG51bGwgPSBudWxsICkge1xyXG5cclxuXHRcdHRoaXMuZW52TWFwU3JjID0gZW52TWFwO1xyXG5cdFx0dGhpcy5lbnZNYXBVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdGlmICggdGhpcy5jb21tb25Vbmlmb3Jtcy5lbnZNYXBJbnRlbnNpdHkudmFsdWUgPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuY29tbW9uVW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gMTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLmNvbW1vblVuaWZvcm1zLmlibEludGVuc2l0eS52YWx1ZSA9PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5pYmxJbnRlbnNpdHkudmFsdWUgPSAxO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0IGVudk1hcEludGVuc2l0eSggdmFsdWU6IG51bWJlciApIHtcclxuXHJcblx0XHR0aGlzLmNvbW1vblVuaWZvcm1zLmVudk1hcEludGVuc2l0eS52YWx1ZSA9IHZhbHVlO1xyXG5cclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXQgaWJsSW50ZW5zaXR5KCB2YWx1ZTogbnVtYmVyICkge1xyXG5cclxuXHRcdHRoaXMuY29tbW9uVW5pZm9ybXMuaWJsSW50ZW5zaXR5LnZhbHVlID0gdmFsdWU7XHJcblxyXG5cdH1cclxuXHJcblx0cHVibGljIGRpc3Bvc2UoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwc29lJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldCBpc1Bvd2VyTWVzaCgpIHtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XHJcbmltcG9ydCAqIGFzIE9SRSBmcm9tICdvcmUtdGhyZWUnO1xyXG5cclxuaW1wb3J0IHsgUG93ZXJNZXNoIH0gZnJvbSAnLi4vUG93ZXJNZXNoJztcclxuXHJcbmltcG9ydCBtaXBtYXBWZXJ0IGZyb20gJy4vc2hhZGVycy9taXBtYXAudnMnO1xyXG5pbXBvcnQgbWlwbWFwRnJhZyBmcm9tICcuL3NoYWRlcnMvbWlwbWFwLmZzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBQb3dlclJlZmxlY3Rpb25NZXNoIGV4dGVuZHMgUG93ZXJNZXNoIHtcclxuXHJcblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0XHRSZW5kZXJUYXJnZXRcclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0cHJpdmF0ZSByZW5kZXJUYXJnZXRzOiB7XHJcblx0XHRyZWY6IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LFxyXG5cdFx0bWlwbWFwOiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldFxyXG5cdH07XHJcblxyXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdFx0TWlwbWFwXHJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdHByaXZhdGUgbWlwbWFwR2VvOiBUSFJFRS5CdWZmZXJHZW9tZXRyeTtcclxuXHRwcml2YXRlIG1pcG1hcFBQOiBPUkUuUG9zdFByb2Nlc3NpbmcgfCBudWxsO1xyXG5cclxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFJlZmxlY3Rpb24gQ2FtZXJhXHJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdHByaXZhdGUgbG9va0F0UG9zaXRpb246IFRIUkVFLlZlY3RvcjM7XHJcblx0cHJpdmF0ZSByb3RhdGlvbk1hdHJpeDogVEhSRUUuTWF0cml4NDtcclxuXHRwcml2YXRlIHRhcmdldDogVEhSRUUuVmVjdG9yMztcclxuXHRwcml2YXRlIHZpZXc6IFRIUkVFLlZlY3RvcjM7XHJcblxyXG5cdHByaXZhdGUgdmlydHVhbENhbWVyYTogVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmE7XHJcblx0cHJpdmF0ZSByZWZsZWN0b3JQbGFuZTogVEhSRUUuUGxhbmU7XHJcblx0cHJpdmF0ZSBub3JtYWw6IFRIUkVFLlZlY3RvcjM7XHJcblxyXG5cdHByaXZhdGUgcmVmbGVjdG9yV29ybGRQb3NpdGlvbjogVEhSRUUuVmVjdG9yMztcclxuXHRwcml2YXRlIGNhbWVyYVdvcmxkUG9zaXRpb246IFRIUkVFLlZlY3RvcjM7XHJcblxyXG5cdHByaXZhdGUgY2xpcFBsYW5lOiBUSFJFRS5WZWN0b3I0O1xyXG5cdHByaXZhdGUgY2xpcEJpYXM6IG51bWJlcjtcclxuXHRwcml2YXRlIHE6IFRIUkVFLlZlY3RvcjQ7XHJcblxyXG5cdHByaXZhdGUgdGV4dHVyZU1hdHJpeDogVEhSRUUuTWF0cml4NDtcclxuXHJcblx0Y29uc3RydWN0b3IoIGdlb21ldHJ5OiBUSFJFRS5CdWZmZXJHZW9tZXRyeSwgbWF0ZXJpYWxPcHRpb24/OiBUSFJFRS5TaGFkZXJNYXRlcmlhbFBhcmFtZXRlcnMsIG92ZXJyaWRlPzogYm9vbGVhbiApO1xyXG5cclxuXHRjb25zdHJ1Y3RvciggbWVzaDogVEhSRUUuTWVzaCwgbWF0ZXJpYWxPcHRpb24/OiBUSFJFRS5TaGFkZXJNYXRlcmlhbFBhcmFtZXRlcnMsIG92ZXJyaWRlPzogYm9vbGVhbiApO1xyXG5cclxuXHRjb25zdHJ1Y3RvciggZ2VvTWVzaDogVEhSRUUuQnVmZmVyR2VvbWV0cnkgfCBUSFJFRS5NZXNoPFRIUkVFLkJ1ZmZlckdlb21ldHJ5PiwgbWF0ZXJpYWxPcHRpb24/OiBUSFJFRS5TaGFkZXJNYXRlcmlhbFBhcmFtZXRlcnMsIG92ZXJyaWRlPzogYm9vbGVhbiApIHtcclxuXHJcblx0XHRtYXRlcmlhbE9wdGlvbiA9IG1hdGVyaWFsT3B0aW9uIHx8IHt9O1xyXG5cclxuXHRcdG1hdGVyaWFsT3B0aW9uLnVuaWZvcm1zID0gT1JFLlVuaWZvcm1zTGliLm1lcmdlVW5pZm9ybXMoIG1hdGVyaWFsT3B0aW9uLnVuaWZvcm1zIHx8IHt9LCB7XHJcblx0XHRcdHJlZmxlY3Rpb25UZXg6IHtcclxuXHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRyZW5kZXJSZXNvbHV0aW9uOiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxIClcclxuXHRcdFx0fSxcclxuXHRcdFx0dGV4dHVyZU1hdHJpeDoge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVEhSRUUuTWF0cml4NCgpXHJcblx0XHRcdH0sXHJcblx0XHRcdG1pcE1hcFJlc29sdXRpb246IHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKVxyXG5cdFx0XHR9XHJcblx0XHR9ICk7XHJcblxyXG5cdFx0bWF0ZXJpYWxPcHRpb24uZGVmaW5lcyA9IHtcclxuXHRcdFx0SVNfUkVGTEVDVElPTlBMQU5FOiAnJyxcclxuXHRcdH07XHJcblxyXG5cdFx0c3VwZXIoIGdlb01lc2ggYXMgVEhSRUUuQnVmZmVyR2VvbWV0cnksIG1hdGVyaWFsT3B0aW9uLCBvdmVycmlkZSApO1xyXG5cclxuXHRcdHRoaXMucmVmbGVjdG9yUGxhbmUgPSBuZXcgVEhSRUUuUGxhbmUoKTtcclxuXHRcdHRoaXMubm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHRoaXMucmVmbGVjdG9yV29ybGRQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR0aGlzLmNhbWVyYVdvcmxkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dGhpcy5yb3RhdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHR0aGlzLmxvb2tBdFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApO1xyXG5cdFx0dGhpcy5jbGlwUGxhbmUgPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xyXG5cdFx0dGhpcy50ZXh0dXJlTWF0cml4ID0gdGhpcy5jb21tb25Vbmlmb3Jtcy50ZXh0dXJlTWF0cml4LnZhbHVlO1xyXG5cdFx0dGhpcy5jbGlwQmlhcyA9IDAuMTtcclxuXHJcblx0XHR0aGlzLnZpZXcgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dGhpcy5xID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0XHR0aGlzLnZpcnR1YWxDYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoKTtcclxuXHJcblx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFx0TWlwTWFwXHJcblx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0XHR0aGlzLm1pcG1hcFBQID0gbnVsbDtcclxuXHRcdHRoaXMubWlwbWFwR2VvID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcblxyXG5cdFx0bGV0IHBvc0FycmF5ID0gW107XHJcblx0XHRsZXQgdXZBcnJheSA9IFtdO1xyXG5cdFx0bGV0IGluZGV4QXJyYXkgPSBbXTtcclxuXHJcblx0XHRsZXQgcCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XHJcblx0XHRsZXQgcyA9IDIuMDtcclxuXHJcblx0XHRwb3NBcnJheS5wdXNoKCBwLngsIHAueSwgMCApO1xyXG5cdFx0cG9zQXJyYXkucHVzaCggcC54ICsgcywgcC55LCAwICk7XHJcblx0XHRwb3NBcnJheS5wdXNoKCBwLnggKyBzLCBwLnkgLSBzLCAwICk7XHJcblx0XHRwb3NBcnJheS5wdXNoKCBwLngsIHAueSAtIHMsIDAgKTtcclxuXHJcblx0XHR1dkFycmF5LnB1c2goIDEuMCwgMS4wICk7XHJcblx0XHR1dkFycmF5LnB1c2goIDAuMCwgMS4wICk7XHJcblx0XHR1dkFycmF5LnB1c2goIDAuMCwgMC4wICk7XHJcblx0XHR1dkFycmF5LnB1c2goIDEuMCwgMC4wICk7XHJcblxyXG5cdFx0aW5kZXhBcnJheS5wdXNoKCAwLCAyLCAxLCAwLCAzLCAyICk7XHJcblxyXG5cdFx0cC5zZXQoIHMsIDAgKTtcclxuXHJcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA3OyBpICsrICkge1xyXG5cclxuXHRcdFx0cyAqPSAwLjU7XHJcblxyXG5cdFx0XHRwb3NBcnJheS5wdXNoKCBwLngsXHRcdHAueSxcdFx0MCApO1xyXG5cdFx0XHRwb3NBcnJheS5wdXNoKCBwLnggKyBzLCBwLnksXHRcdDAgKTtcclxuXHRcdFx0cG9zQXJyYXkucHVzaCggcC54ICsgcywgcC55IC0gcyxcdDAgKTtcclxuXHRcdFx0cG9zQXJyYXkucHVzaCggcC54LFx0XHRwLnkgLSBzLCBcdDAgKTtcclxuXHJcblx0XHRcdHV2QXJyYXkucHVzaCggMS4wLCAxLjAgKTtcclxuXHRcdFx0dXZBcnJheS5wdXNoKCAwLjAsIDEuMCApO1xyXG5cdFx0XHR1dkFycmF5LnB1c2goIDAuMCwgMC4wICk7XHJcblx0XHRcdHV2QXJyYXkucHVzaCggMS4wLCAwLjAgKTtcclxuXHJcblx0XHRcdGxldCBpbmRleE9mZnNldCA9ICggaSArIDAuMCApICogNDtcclxuXHRcdFx0aW5kZXhBcnJheS5wdXNoKCBpbmRleE9mZnNldCArIDAsIGluZGV4T2Zmc2V0ICsgMiwgaW5kZXhPZmZzZXQgKyAxLCBpbmRleE9mZnNldCArIDAsIGluZGV4T2Zmc2V0ICsgMywgaW5kZXhPZmZzZXQgKyAyICk7XHJcblxyXG5cdFx0XHRwLnkgPSBwLnkgLSBzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgcG9zQXR0ciA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHBvc0FycmF5ICksIDMgKTtcclxuXHRcdGxldCB1dkF0dHIgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB1dkFycmF5ICksIDIgKTtcclxuXHRcdGxldCBpbmRleEF0dHIgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGV4QXJyYXkgKSwgMSApO1xyXG5cclxuXHRcdGxldCBncyA9IDE7XHJcblx0XHRwb3NBdHRyLmFwcGx5TWF0cml4NCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlU2NhbGUoICggMS4wIC8gMS41ICksIGdzLCBncyApICk7XHJcblx0XHRwb3NBdHRyLmFwcGx5TWF0cml4NCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oIC0gMS4wLCAxLjAsIDAgKSApO1xyXG5cclxuXHRcdHRoaXMubWlwbWFwR2VvLnNldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zQXR0ciApO1xyXG5cdFx0dGhpcy5taXBtYXBHZW8uc2V0QXR0cmlidXRlKCAndXYnLCB1dkF0dHIgKTtcclxuXHRcdHRoaXMubWlwbWFwR2VvLnNldEluZGV4KCBpbmRleEF0dHIgKTtcclxuXHJcblx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFx0UmVuZGVyVGFyZ2V0c1xyXG5cdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRzID0ge1xyXG5cdFx0XHRyZWY6IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggMSwgMSApLFxyXG5cdFx0XHRtaXBtYXA6IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggMSwgMSApLFxyXG5cdFx0fTtcclxuXHJcblx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFx0UmVmbGVjdGlvblxyXG5cdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG5cdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCAnYmVmb3JlUmVuZGVyJywgKCBlOiBUSFJFRS5FdmVudCApID0+IHtcclxuXHJcblx0XHRcdGxldCByZW5kZXJlciA9IGUucmVuZGVyZXIgYXMgVEhSRUUuV2ViR0xSZW5kZXJlcjtcclxuXHRcdFx0bGV0IHNjZW5lID0gZS5zY2VuZSBhcyBUSFJFRS5TY2VuZTtcclxuXHRcdFx0bGV0IGNhbWVyYSA9IGUuY2FtZXJhIGFzIFRIUkVFLkNhbWVyYTtcclxuXHJcblx0XHRcdHRoaXMucmVmbGVjdG9yV29ybGRQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcclxuXHRcdFx0dGhpcy5jYW1lcmFXb3JsZFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHR0aGlzLnJvdGF0aW9uTWF0cml4LmV4dHJhY3RSb3RhdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0dGhpcy5ub3JtYWwuc2V0KCAwLCAxLjAsIDAgKTtcclxuXHRcdFx0dGhpcy5ub3JtYWwuYXBwbHlNYXRyaXg0KCB0aGlzLnJvdGF0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHR0aGlzLnZpZXcuc3ViVmVjdG9ycyggdGhpcy5yZWZsZWN0b3JXb3JsZFBvc2l0aW9uLCB0aGlzLmNhbWVyYVdvcmxkUG9zaXRpb24gKTtcclxuXHJcblx0XHRcdC8vIEF2b2lkIHJlbmRlcmluZyB3aGVuIHJlZmxlY3RvciBpcyBmYWNpbmcgYXdheVxyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnZpZXcuZG90KCB0aGlzLm5vcm1hbCApID4gMCApIHJldHVybjtcclxuXHJcblx0XHRcdHRoaXMudmlldy5yZWZsZWN0KCB0aGlzLm5vcm1hbCApLm5lZ2F0ZSgpO1xyXG5cdFx0XHR0aGlzLnZpZXcuYWRkKCB0aGlzLnJlZmxlY3RvcldvcmxkUG9zaXRpb24gKTtcclxuXHJcblx0XHRcdHRoaXMucm90YXRpb25NYXRyaXguZXh0cmFjdFJvdGF0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdHRoaXMubG9va0F0UG9zaXRpb24uc2V0KCAwLCAwLCAtIDEgKTtcclxuXHRcdFx0dGhpcy5sb29rQXRQb3NpdGlvbi5hcHBseU1hdHJpeDQoIHRoaXMucm90YXRpb25NYXRyaXggKTtcclxuXHRcdFx0dGhpcy5sb29rQXRQb3NpdGlvbi5hZGQoIHRoaXMuY2FtZXJhV29ybGRQb3NpdGlvbiApO1xyXG5cclxuXHRcdFx0dGhpcy50YXJnZXQuc3ViVmVjdG9ycyggdGhpcy5yZWZsZWN0b3JXb3JsZFBvc2l0aW9uLCB0aGlzLmxvb2tBdFBvc2l0aW9uICk7XHJcblx0XHRcdHRoaXMudGFyZ2V0LnJlZmxlY3QoIHRoaXMubm9ybWFsICkubmVnYXRlKCk7XHJcblx0XHRcdHRoaXMudGFyZ2V0LmFkZCggdGhpcy5yZWZsZWN0b3JXb3JsZFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHR0aGlzLnZpcnR1YWxDYW1lcmEucG9zaXRpb24uY29weSggdGhpcy52aWV3ICk7XHJcblx0XHRcdHRoaXMudmlydHVhbENhbWVyYS51cC5zZXQoIDAsIDEsIDAgKTtcclxuXHRcdFx0dGhpcy52aXJ0dWFsQ2FtZXJhLnVwLmFwcGx5TWF0cml4NCggdGhpcy5yb3RhdGlvbk1hdHJpeCApO1xyXG5cdFx0XHR0aGlzLnZpcnR1YWxDYW1lcmEudXAucmVmbGVjdCggdGhpcy5ub3JtYWwgKTtcclxuXHRcdFx0dGhpcy52aXJ0dWFsQ2FtZXJhLmxvb2tBdCggdGhpcy50YXJnZXQgKTtcclxuXHJcblx0XHRcdGlmICggKCBjYW1lcmEgYXMgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgKS5mYXIgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudmlydHVhbENhbWVyYS5mYXIgPSAoIGNhbWVyYSBhcyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSApLmZhcjsgLy8gVXNlZCBpbiBXZWJHTEJhY2tncm91bmRcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMudmlydHVhbENhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xyXG5cdFx0XHR0aGlzLnZpcnR1YWxDYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHRoZSB0ZXh0dXJlIG1hdHJpeFxyXG5cdFx0XHR0aGlzLnRleHR1cmVNYXRyaXguc2V0KFxyXG5cdFx0XHRcdDAuNSwgMC4wLCAwLjAsIDAuNSxcclxuXHRcdFx0XHQwLjAsIDAuNSwgMC4wLCAwLjUsXHJcblx0XHRcdFx0MC4wLCAwLjAsIDAuNSwgMC41LFxyXG5cdFx0XHRcdDAuMCwgMC4wLCAwLjAsIDEuMFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0dXJlTWF0cml4Lm11bHRpcGx5KCB0aGlzLnZpcnR1YWxDYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cdFx0XHR0aGlzLnRleHR1cmVNYXRyaXgubXVsdGlwbHkoIHRoaXMudmlydHVhbENhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0dGhpcy50ZXh0dXJlTWF0cml4Lm11bHRpcGx5KCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHQvLyBOb3cgdXBkYXRlIHByb2plY3Rpb24gbWF0cml4IHdpdGggbmV3IGNsaXAgcGxhbmUsIGltcGxlbWVudGluZyBjb2RlIGZyb206IGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvb2JsaXF1ZS5odG1sXHJcblx0XHRcdC8vIFBhcGVyIGV4cGxhaW5pbmcgdGhpcyB0ZWNobmlxdWU6IGh0dHA6Ly93d3cudGVyYXRob24uY29tL2xlbmd5ZWwvTGVuZ3llbC1PYmxpcXVlLnBkZlxyXG5cdFx0XHR0aGlzLnJlZmxlY3RvclBsYW5lLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCB0aGlzLm5vcm1hbCwgdGhpcy5yZWZsZWN0b3JXb3JsZFBvc2l0aW9uICk7XHJcblx0XHRcdHRoaXMucmVmbGVjdG9yUGxhbmUuYXBwbHlNYXRyaXg0KCB0aGlzLnZpcnR1YWxDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0XHR0aGlzLmNsaXBQbGFuZS5zZXQoIHRoaXMucmVmbGVjdG9yUGxhbmUubm9ybWFsLngsIHRoaXMucmVmbGVjdG9yUGxhbmUubm9ybWFsLnksIHRoaXMucmVmbGVjdG9yUGxhbmUubm9ybWFsLnosIHRoaXMucmVmbGVjdG9yUGxhbmUuY29uc3RhbnQgKTtcclxuXHJcblx0XHRcdHZhciBwcm9qZWN0aW9uTWF0cml4ID0gdGhpcy52aXJ0dWFsQ2FtZXJhLnByb2plY3Rpb25NYXRyaXg7XHJcblxyXG5cdFx0XHR0aGlzLnEueCA9ICggTWF0aC5zaWduKCB0aGlzLmNsaXBQbGFuZS54ICkgKyBwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA4IF0gKSAvIHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXTtcclxuXHRcdFx0dGhpcy5xLnkgPSAoIE1hdGguc2lnbiggdGhpcy5jbGlwUGxhbmUueSApICsgcHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOSBdICkgLyBwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA1IF07XHJcblx0XHRcdHRoaXMucS56ID0gLSAxLjA7XHJcblx0XHRcdHRoaXMucS53ID0gKCAxLjAgKyBwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAxMCBdICkgLyBwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAxNCBdO1xyXG5cclxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBzY2FsZWQgcGxhbmUgdmVjdG9yXHJcblx0XHRcdHRoaXMuY2xpcFBsYW5lLm11bHRpcGx5U2NhbGFyKCAyLjAgLyB0aGlzLmNsaXBQbGFuZS5kb3QoIHRoaXMucSApICk7XHJcblxyXG5cdFx0XHQvLyBSZXBsYWNpbmcgdGhlIHRoaXJkIHJvdyBvZiB0aGUgcHJvamVjdGlvbiBtYXRyaXhcclxuXHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMiBdID0gdGhpcy5jbGlwUGxhbmUueDtcclxuXHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgNiBdID0gdGhpcy5jbGlwUGxhbmUueTtcclxuXHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMTAgXSA9IHRoaXMuY2xpcFBsYW5lLnogKyAxLjAgLSB0aGlzLmNsaXBCaWFzO1xyXG5cdFx0XHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAxNCBdID0gdGhpcy5jbGlwUGxhbmUudztcclxuXHJcblx0XHRcdC8vcmVuZGVyXHJcblx0XHRcdGxldCBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHRoaXMucmVuZGVyVGFyZ2V0cy5yZWYgKTtcclxuXHRcdFx0dGhpcy52aXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRyZW5kZXJlci5jbGVhcigpO1xyXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCB0aGlzLnZpcnR1YWxDYW1lcmEgKTtcclxuXHRcdFx0cmVuZGVyZXIuY2xlYXJEZXB0aCgpO1xyXG5cclxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBjdXJyZW50UmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG5cdFx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdFx0XHRNaXBNYXBQUFxyXG5cdFx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcblx0XHRcdGlmICggdGhpcy5taXBtYXBQUCA9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1pcG1hcFBQID0gbmV3IE9SRS5Qb3N0UHJvY2Vzc2luZyggcmVuZGVyZXIsIHtcclxuXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBtaXBtYXBGcmFnLFxyXG5cdFx0XHRcdFx0c2lkZTogVEhSRUUuRG91YmxlU2lkZVxyXG5cdFx0XHRcdH0sIHRoaXMubWlwbWFwR2VvICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1pcG1hcFBQLnJlbmRlciggeyB0ZXg6IHRoaXMucmVuZGVyVGFyZ2V0cy5yZWYudGV4dHVyZSB9LCB0aGlzLnJlbmRlclRhcmdldHMubWlwbWFwICk7XHJcblx0XHRcdHRoaXMuY29tbW9uVW5pZm9ybXMucmVmbGVjdGlvblRleC52YWx1ZSA9IHRoaXMucmVuZGVyVGFyZ2V0cy5taXBtYXAudGV4dHVyZTtcclxuXHJcblx0XHRcdGxldCBydCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpIGFzIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0O1xyXG5cclxuXHRcdFx0aWYgKCBydCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5yZW5kZXJSZXNvbHV0aW9uLnZhbHVlLnNldCggcnQud2lkdGgsIHJ0LmhlaWdodCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyZXIuZ2V0U2l6ZSggdGhpcy5jb21tb25Vbmlmb3Jtcy5yZW5kZXJSZXNvbHV0aW9uLnZhbHVlICk7XHJcblx0XHRcdFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5yZW5kZXJSZXNvbHV0aW9uLnZhbHVlLm11bHRpcGx5U2NhbGFyKCByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0dGhpcy5yZXNpemUoKTtcclxuXHJcblx0fVxyXG5cclxuXHRwdWJsaWMgcmVzaXplKCBzaXplOiBUSFJFRS5WZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjIgICkge1xyXG5cclxuXHRcdHRoaXMucmVuZGVyVGFyZ2V0cy5yZWYuc2V0U2l6ZSggc2l6ZS54LCBzaXplLnkgKTtcclxuXHJcblx0XHRsZXQgbWlwTWFwU2l6ZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBzaXplLnggKiAxLjUsIHNpemUueSApO1xyXG5cdFx0dGhpcy5yZW5kZXJUYXJnZXRzLm1pcG1hcC5zZXRTaXplKCBtaXBNYXBTaXplLngsIG1pcE1hcFNpemUueSApO1xyXG5cdFx0dGhpcy5jb21tb25Vbmlmb3Jtcy5taXBNYXBSZXNvbHV0aW9uLnZhbHVlLmNvcHkoIG1pcE1hcFNpemUgKTtcclxuXHJcblx0fVxyXG5cclxufVxyXG4iLCJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgR0xTTElGWSAxXFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4O1xcbnZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuZmxvYXQgY2xpcCggdmVjMiB1diApIHtcXG5cXHR2ZWMyIGMgPSBzdGVwKCBhYnModXYgLSAwLjUpLCB2ZWMyKCAwLjUgKSApO1xcblxcdHJldHVybiBjLnggKiBjLnk7XFxufVxcblxcbnZvaWQgbWFpbiggdm9pZCApIHtcXG5cXG5cXHR2ZWM0IGNvbCA9IHRleHR1cmUyRCggdGV4LCB2VXYgKTtcXG5cXHRnbF9GcmFnQ29sb3IgPSBjb2w7XFxuXFxufVwiOyJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiZGVmaW5lIiwiYW1kIiwidGhpcyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM4MV9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNjk5X18iLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJ1bmRlZmluZWQiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiZCIsImRlZmluaXRpb24iLCJrZXkiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwib2JqIiwicHJvcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInIiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwiUG93ZXJNZXNoIiwiY29uc3RydWN0b3IiLCJnZW9NZXNoIiwibWF0ZXJpYWxPcHRpb24iLCJvdmVycmlkZSIsImdlbyIsInVuaSIsInVuaWZvcm1zIiwiZW52TWFwIiwiZW52TWFwSW50ZW5zaXR5IiwiaWJsSW50ZW5zaXR5IiwibWF4TG9kTGV2ZWwiLCJzaGFkb3dMaWdodE1vZGVsVmlld01hdHJpeCIsInNoYWRvd0xpZ2h0UHJvamVjdGlvbk1hdHJpeCIsInNoYWRvd0xpZ2h0RGlyZWN0aW9uIiwic2hhZG93TGlnaHRDYW1lcmFDbGlwIiwic2hhZG93TWFwIiwic2hhZG93TWFwU2l6ZSIsInNoYWRvd01hcFJlc29sdXRpb24iLCJzaGFkb3dMaWdodFNpemUiLCJjYW1lcmFOZWFyIiwiY2FtZXJhRmFyIiwiY29sb3IiLCJtZXRhbG5lc3MiLCJyb3VnaG5lc3MiLCJvcGFjaXR5IiwiZW1pc3Npb24iLCJnZW9tZXRyeSIsIm1hdCIsIm1hdGVyaWFsIiwiaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCIsIm1hcCIsImNvcHkiLCJyb3VnaG5lc3NNYXAiLCJhbHBoYU1hcCIsIm1ldGFsbmVzc01hcCIsIm5vcm1hbE1hcCIsImVtaXNzaXZlTWFwIiwiZW1pc3Npb25NYXAiLCJlbWlzc2l2ZSIsImdldEF0dHJpYnV0ZSIsImdldEluZGV4IiwiY29tcHV0ZVRhbmdlbnRzIiwidmVydGV4U2hhZGVyIiwicG93ZXIiLCJmcmFnbWVudFNoYWRlciIsImxpZ2h0cyIsInRyYW5zcGFyZW50Iiwic2lkZSIsImV4dGVuc2lvbnMiLCJkZXJpdmF0aXZlcyIsImRlZmluZXMiLCJVU0VfTUFQIiwiVVNFX1JPVUdITkVTU19NQVAiLCJVU0VfTUVUQUxORVNTX01BUCIsIlVTRV9BTFBIQV9NQVAiLCJVU0VfTk9STUFMX01BUCIsIlVTRV9FTUlTU0lPTl9NQVAiLCJzdXBlciIsIm5hbWUiLCJ1c2VyRGF0YSIsImNvbG9yTWF0IiwiY3VzdG9tRGVwdGhNYXRlcmlhbCIsImNvbW1vblVuaWZvcm1zIiwiZGlzcG9zZSIsImNoaWxkcmVuIiwic2xpY2UiLCJmb3JFYWNoIiwiY2hpbGQiLCJhZGQiLCJwb3NpdGlvbiIsInJvdGF0aW9uIiwic2NhbGUiLCJwYXJlbnQiLCJyZW1vdmUiLCJhbmltYXRpb25zIiwiaXRlbSIsInB1c2giLCJza2VsZXRvbiIsImVudk1hcFNyYyIsImVudk1hcFVwZGF0ZSIsImVudk1hcFJlc29sdXRpb24iLCJlbnZNYXBSZW5kZXJUYXJnZXQiLCJmb3JtYXQiLCJnZW5lcmF0ZU1pcG1hcHMiLCJtYWdGaWx0ZXIiLCJtaW5GaWx0ZXIiLCJlbnZNYXBDYW1lcmEiLCJnZXRXb3JsZFBvc2l0aW9uIiwib25CZWZvcmVSZW5kZXIiLCJyZW5kZXJlciIsInNjZW5lIiwiY2FtZXJhIiwiZGlzcGF0Y2hFdmVudCIsInR5cGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImVudk1hcFJUIiwicG1yZW1HZW5lcmF0b3IiLCJjb21waWxlRXF1aXJlY3Rhbmd1bGFyU2hhZGVyIiwiZnJvbUN1YmVtYXAiLCJmcm9tRXF1aXJlY3Rhbmd1bGFyIiwidmlzaWJsZSIsInVwZGF0ZSIsInRleHR1cmUiLCJoZWlnaHQiLCJtYXhNaXAiLCJNYXRoIiwicm91bmQiLCJsb2cyIiwidGV4ZWxIZWlnaHQiLCJ0ZXhlbFdpZHRoIiwibWF4IiwicG93IiwiZGVwdGhDYW1lcmEiLCJkZXB0aE1hdCIsIm5lYXIiLCJmYXIiLCJvbkRpc3Bvc2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidXBkYXRlRW52TWFwIiwiaXNQb3dlck1lc2giLCJQb3dlclJlZmxlY3Rpb25NZXNoIiwicmVmbGVjdGlvblRleCIsInJlbmRlclJlc29sdXRpb24iLCJ0ZXh0dXJlTWF0cml4IiwibWlwTWFwUmVzb2x1dGlvbiIsIklTX1JFRkxFQ1RJT05QTEFORSIsInJlZmxlY3RvclBsYW5lIiwibm9ybWFsIiwicmVmbGVjdG9yV29ybGRQb3NpdGlvbiIsImNhbWVyYVdvcmxkUG9zaXRpb24iLCJyb3RhdGlvbk1hdHJpeCIsImxvb2tBdFBvc2l0aW9uIiwiY2xpcFBsYW5lIiwiY2xpcEJpYXMiLCJ2aWV3IiwidGFyZ2V0IiwicSIsInZpcnR1YWxDYW1lcmEiLCJtaXBtYXBQUCIsIm1pcG1hcEdlbyIsInBvc0FycmF5IiwidXZBcnJheSIsImluZGV4QXJyYXkiLCJwIiwicyIsIngiLCJ5Iiwic2V0IiwiaSIsImluZGV4T2Zmc2V0IiwicG9zQXR0ciIsIkZsb2F0MzJBcnJheSIsInV2QXR0ciIsImluZGV4QXR0ciIsIlVpbnQxNkFycmF5IiwiYXBwbHlNYXRyaXg0IiwibWFrZVNjYWxlIiwibWFrZVRyYW5zbGF0aW9uIiwic2V0QXR0cmlidXRlIiwic2V0SW5kZXgiLCJyZW5kZXJUYXJnZXRzIiwicmVmIiwibWlwbWFwIiwic2V0RnJvbU1hdHJpeFBvc2l0aW9uIiwibWF0cml4V29ybGQiLCJleHRyYWN0Um90YXRpb24iLCJzdWJWZWN0b3JzIiwiZG90IiwicmVmbGVjdCIsIm5lZ2F0ZSIsInVwIiwibG9va0F0IiwidXBkYXRlTWF0cml4V29ybGQiLCJwcm9qZWN0aW9uTWF0cml4IiwibXVsdGlwbHkiLCJtYXRyaXhXb3JsZEludmVyc2UiLCJzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCIsInoiLCJjb25zdGFudCIsInNpZ24iLCJlbGVtZW50cyIsInciLCJtdWx0aXBseVNjYWxhciIsImN1cnJlbnRSZW5kZXJUYXJnZXQiLCJnZXRSZW5kZXJUYXJnZXQiLCJzZXRSZW5kZXJUYXJnZXQiLCJjbGVhciIsInJlbmRlciIsImNsZWFyRGVwdGgiLCJ0ZXgiLCJydCIsIndpZHRoIiwiZ2V0U2l6ZSIsImdldFBpeGVsUmF0aW8iLCJyZXNpemUiLCJzaXplIiwic2V0U2l6ZSIsIm1pcE1hcFNpemUiXSwic291cmNlUm9vdCI6IiJ9